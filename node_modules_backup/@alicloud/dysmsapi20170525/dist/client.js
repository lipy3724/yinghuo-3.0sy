"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubmitSmsQualificationRequestOtherFiles = exports.SubmitSmsQualificationRequestBusinessLicensePics = exports.SendCardSmsResponseBodyData = exports.SendCardSmsRequestCardObjects = exports.SendBatchCardSmsResponseBodyData = exports.QuerySmsTemplateListResponseBodySmsTemplateList = exports.QuerySmsTemplateListResponseBodySmsTemplateListReason = exports.QuerySmsSignListResponseBodySmsSignList = exports.QuerySmsSignListResponseBodySmsSignListReason = exports.QuerySmsQualificationRecordResponseBodyData = exports.QuerySmsQualificationRecordResponseBodyDataList = exports.QuerySmsAuthorizationLetterResponseBodyData = exports.QuerySingleSmsQualificationResponseBodyData = exports.QuerySingleSmsQualificationResponseBodyDataOtherFiles = exports.QuerySingleSmsQualificationResponseBodyDataBusinessLicensePics = exports.QueryShortUrlResponseBodyData = exports.QuerySendStatisticsResponseBodyData = exports.QuerySendStatisticsResponseBodyDataTargetList = exports.QuerySendDetailsResponseBodySmsSendDetailDTOs = exports.QuerySendDetailsResponseBodySmsSendDetailDTOsSmsSendDetailDTO = exports.QueryPageSmartShortUrlLogResponseBodyModel = exports.QueryPageSmartShortUrlLogResponseBodyModelList = exports.QueryMobilesCardSupportResponseBodyData = exports.QueryMobilesCardSupportResponseBodyDataQueryResult = exports.QueryExtCodeSignResponseBodyData = exports.QueryExtCodeSignResponseBodyDataList = exports.QueryCardSmsTemplateReportResponseBodyData = exports.QueryCardSmsTemplateResponseBodyData = exports.ModifySmsSignRequestSignFileList = exports.ListTagResourcesResponseBodyTagResources = exports.ListTagResourcesResponseBodyTagResourcesTagResource = exports.ListTagResourcesRequestTag = exports.GetSmsTemplateResponseBodyMoreDataFileUrlList = exports.GetSmsTemplateResponseBodyFileUrlList = exports.GetSmsTemplateResponseBodyAuditInfo = exports.GetSmsSignResponseBodyAuditInfo = exports.GetQualificationOssInfoResponseBodyData = exports.GetOSSInfoForUploadFileResponseBodyModel = exports.GetOSSInfoForCardTemplateResponseBodyData = exports.GetMediaResourceIdResponseBodyData = exports.GetCardSmsLinkResponseBodyData = exports.GetCardSmsDetailsResponseBodyCardSendDetailDTO = exports.GetCardSmsDetailsResponseBodyCardSendDetailDTORecords = exports.CreateSmartShortUrlResponseBodyModel = exports.CreateCardSmsTemplateResponseBodyData = exports.CheckMobilesCardSupportResponseBodyData = exports.CheckMobilesCardSupportResponseBodyDataQueryResult = exports.ChangeSignatureQualificationResponseBodyData = exports.AddSmsSignRequestSignFileList = exports.AddShortUrlResponseBodyData = void 0;
exports.DeleteSmsQualificationRequest = exports.DeleteShortUrlResponse = exports.DeleteShortUrlResponseBody = exports.DeleteShortUrlRequest = exports.DeleteExtCodeSignResponse = exports.DeleteExtCodeSignResponseBody = exports.DeleteExtCodeSignRequest = exports.CreateSmsTemplateResponse = exports.CreateSmsTemplateResponseBody = exports.CreateSmsTemplateShrinkRequest = exports.CreateSmsTemplateRequest = exports.CreateSmsSignResponse = exports.CreateSmsSignResponseBody = exports.CreateSmsSignShrinkRequest = exports.CreateSmsSignRequest = exports.CreateSmsAuthorizationLetterResponse = exports.CreateSmsAuthorizationLetterResponseBody = exports.CreateSmsAuthorizationLetterShrinkRequest = exports.CreateSmsAuthorizationLetterRequest = exports.CreateSmartShortUrlResponse = exports.CreateSmartShortUrlResponseBody = exports.CreateSmartShortUrlRequest = exports.CreateCardSmsTemplateResponse = exports.CreateCardSmsTemplateResponseBody = exports.CreateCardSmsTemplateShrinkRequest = exports.CreateCardSmsTemplateRequest = exports.ConversionDataIntlResponse = exports.ConversionDataIntlResponseBody = exports.ConversionDataIntlRequest = exports.CheckMobilesCardSupportResponse = exports.CheckMobilesCardSupportResponseBody = exports.CheckMobilesCardSupportRequest = exports.ChangeSignatureQualificationResponse = exports.ChangeSignatureQualificationResponseBody = exports.ChangeSignatureQualificationRequest = exports.AddSmsTemplateResponse = exports.AddSmsTemplateResponseBody = exports.AddSmsTemplateRequest = exports.AddSmsSignResponse = exports.AddSmsSignResponseBody = exports.AddSmsSignRequest = exports.AddShortUrlResponse = exports.AddShortUrlResponseBody = exports.AddShortUrlRequest = exports.AddExtCodeSignResponse = exports.AddExtCodeSignResponseBody = exports.AddExtCodeSignRequest = exports.UpdateSmsQualificationRequestOtherFiles = exports.UpdateSmsQualificationRequestBusinessLicensePics = exports.TagResourcesRequestTag = void 0;
exports.QueryMobilesCardSupportRequest = exports.QueryExtCodeSignResponse = exports.QueryExtCodeSignResponseBody = exports.QueryExtCodeSignRequest = exports.QueryCardSmsTemplateReportResponse = exports.QueryCardSmsTemplateReportResponseBody = exports.QueryCardSmsTemplateReportRequest = exports.QueryCardSmsTemplateResponse = exports.QueryCardSmsTemplateResponseBody = exports.QueryCardSmsTemplateRequest = exports.ModifySmsTemplateResponse = exports.ModifySmsTemplateResponseBody = exports.ModifySmsTemplateRequest = exports.ModifySmsSignResponse = exports.ModifySmsSignResponseBody = exports.ModifySmsSignRequest = exports.ListTagResourcesResponse = exports.ListTagResourcesResponseBody = exports.ListTagResourcesRequest = exports.GetSmsTemplateResponse = exports.GetSmsTemplateResponseBody = exports.GetSmsTemplateRequest = exports.GetSmsSignResponse = exports.GetSmsSignResponseBody = exports.GetSmsSignRequest = exports.GetQualificationOssInfoResponse = exports.GetQualificationOssInfoResponseBody = exports.GetQualificationOssInfoRequest = exports.GetOSSInfoForUploadFileResponse = exports.GetOSSInfoForUploadFileResponseBody = exports.GetOSSInfoForUploadFileRequest = exports.GetOSSInfoForCardTemplateResponse = exports.GetOSSInfoForCardTemplateResponseBody = exports.GetMediaResourceIdResponse = exports.GetMediaResourceIdResponseBody = exports.GetMediaResourceIdRequest = exports.GetCardSmsLinkResponse = exports.GetCardSmsLinkResponseBody = exports.GetCardSmsLinkRequest = exports.GetCardSmsDetailsResponse = exports.GetCardSmsDetailsResponseBody = exports.GetCardSmsDetailsRequest = exports.DeleteSmsTemplateResponse = exports.DeleteSmsTemplateResponseBody = exports.DeleteSmsTemplateRequest = exports.DeleteSmsSignResponse = exports.DeleteSmsSignResponseBody = exports.DeleteSmsSignRequest = exports.DeleteSmsQualificationResponse = exports.DeleteSmsQualificationResponseBody = void 0;
exports.SendSmsRequest = exports.SendCardSmsResponse = exports.SendCardSmsResponseBody = exports.SendCardSmsRequest = exports.SendBatchSmsResponse = exports.SendBatchSmsResponseBody = exports.SendBatchSmsRequest = exports.SendBatchCardSmsResponse = exports.SendBatchCardSmsResponseBody = exports.SendBatchCardSmsRequest = exports.RequiredPhoneCodeResponse = exports.RequiredPhoneCodeResponseBody = exports.RequiredPhoneCodeRequest = exports.QuerySmsTemplateListResponse = exports.QuerySmsTemplateListResponseBody = exports.QuerySmsTemplateListRequest = exports.QuerySmsTemplateResponse = exports.QuerySmsTemplateResponseBody = exports.QuerySmsTemplateRequest = exports.QuerySmsSignListResponse = exports.QuerySmsSignListResponseBody = exports.QuerySmsSignListRequest = exports.QuerySmsSignResponse = exports.QuerySmsSignResponseBody = exports.QuerySmsSignRequest = exports.QuerySmsQualificationRecordResponse = exports.QuerySmsQualificationRecordResponseBody = exports.QuerySmsQualificationRecordRequest = exports.QuerySmsAuthorizationLetterResponse = exports.QuerySmsAuthorizationLetterResponseBody = exports.QuerySmsAuthorizationLetterShrinkRequest = exports.QuerySmsAuthorizationLetterRequest = exports.QuerySingleSmsQualificationResponse = exports.QuerySingleSmsQualificationResponseBody = exports.QuerySingleSmsQualificationRequest = exports.QueryShortUrlResponse = exports.QueryShortUrlResponseBody = exports.QueryShortUrlRequest = exports.QuerySendStatisticsResponse = exports.QuerySendStatisticsResponseBody = exports.QuerySendStatisticsRequest = exports.QuerySendDetailsResponse = exports.QuerySendDetailsResponseBody = exports.QuerySendDetailsRequest = exports.QueryPageSmartShortUrlLogResponse = exports.QueryPageSmartShortUrlLogResponseBody = exports.QueryPageSmartShortUrlLogRequest = exports.QueryMobilesCardSupportResponse = exports.QueryMobilesCardSupportResponseBody = exports.QueryMobilesCardSupportShrinkRequest = void 0;
exports.ValidPhoneCodeResponse = exports.ValidPhoneCodeResponseBody = exports.ValidPhoneCodeRequest = exports.UpdateSmsTemplateResponse = exports.UpdateSmsTemplateResponseBody = exports.UpdateSmsTemplateShrinkRequest = exports.UpdateSmsTemplateRequest = exports.UpdateSmsSignResponse = exports.UpdateSmsSignResponseBody = exports.UpdateSmsSignShrinkRequest = exports.UpdateSmsSignRequest = exports.UpdateSmsQualificationResponse = exports.UpdateSmsQualificationResponseBody = exports.UpdateSmsQualificationShrinkRequest = exports.UpdateSmsQualificationRequest = exports.UpdateExtCodeSignResponse = exports.UpdateExtCodeSignResponseBody = exports.UpdateExtCodeSignRequest = exports.UntagResourcesResponse = exports.UntagResourcesResponseBody = exports.UntagResourcesRequest = exports.TagResourcesResponse = exports.TagResourcesResponseBody = exports.TagResourcesRequest = exports.SubmitSmsQualificationResponse = exports.SubmitSmsQualificationResponseBody = exports.SubmitSmsQualificationShrinkRequest = exports.SubmitSmsQualificationRequest = exports.SmsConversionIntlResponse = exports.SmsConversionIntlResponseBody = exports.SmsConversionIntlRequest = exports.SendSmsResponse = exports.SendSmsResponseBody = void 0;
// This file is auto-generated, don't edit it
/**
 */
const openapi_core_1 = __importDefault(require("@alicloud/openapi-core"));
const openapi_core_2 = require("@alicloud/openapi-core");
const $dara = __importStar(require("@darabonba/typescript"));
class AddShortUrlResponseBodyData extends $dara.Model {
    static names() {
        return {
            expireDate: 'ExpireDate',
            shortUrl: 'ShortUrl',
            sourceUrl: 'SourceUrl',
        };
    }
    static types() {
        return {
            expireDate: 'string',
            shortUrl: 'string',
            sourceUrl: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddShortUrlResponseBodyData = AddShortUrlResponseBodyData;
class AddSmsSignRequestSignFileList extends $dara.Model {
    static names() {
        return {
            fileContents: 'FileContents',
            fileSuffix: 'FileSuffix',
        };
    }
    static types() {
        return {
            fileContents: 'string',
            fileSuffix: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddSmsSignRequestSignFileList = AddSmsSignRequestSignFileList;
class ChangeSignatureQualificationResponseBodyData extends $dara.Model {
    static names() {
        return {
            data: 'Data',
            errCode: 'ErrCode',
            errMessage: 'ErrMessage',
            success: 'Success',
        };
    }
    static types() {
        return {
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            errCode: 'string',
            errMessage: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data) {
            $dara.Model.validateMap(this.data);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ChangeSignatureQualificationResponseBodyData = ChangeSignatureQualificationResponseBodyData;
class CheckMobilesCardSupportResponseBodyDataQueryResult extends $dara.Model {
    static names() {
        return {
            mobile: 'mobile',
            support: 'support',
        };
    }
    static types() {
        return {
            mobile: 'string',
            support: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckMobilesCardSupportResponseBodyDataQueryResult = CheckMobilesCardSupportResponseBodyDataQueryResult;
class CheckMobilesCardSupportResponseBodyData extends $dara.Model {
    static names() {
        return {
            queryResult: 'queryResult',
        };
    }
    static types() {
        return {
            queryResult: { 'type': 'array', 'itemType': CheckMobilesCardSupportResponseBodyDataQueryResult },
        };
    }
    validate() {
        if (Array.isArray(this.queryResult)) {
            $dara.Model.validateArray(this.queryResult);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckMobilesCardSupportResponseBodyData = CheckMobilesCardSupportResponseBodyData;
class CreateCardSmsTemplateResponseBodyData extends $dara.Model {
    static names() {
        return {
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCardSmsTemplateResponseBodyData = CreateCardSmsTemplateResponseBodyData;
class CreateSmartShortUrlResponseBodyModel extends $dara.Model {
    static names() {
        return {
            domain: 'Domain',
            expiration: 'Expiration',
            phoneNumber: 'PhoneNumber',
            shortName: 'ShortName',
            shortUrl: 'ShortUrl',
        };
    }
    static types() {
        return {
            domain: 'string',
            expiration: 'number',
            phoneNumber: 'string',
            shortName: 'string',
            shortUrl: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmartShortUrlResponseBodyModel = CreateSmartShortUrlResponseBodyModel;
class GetCardSmsDetailsResponseBodyCardSendDetailDTORecords extends $dara.Model {
    static names() {
        return {
            errCode: 'ErrCode',
            outId: 'OutId',
            phoneNumber: 'PhoneNumber',
            receiveDate: 'ReceiveDate',
            receiveType: 'ReceiveType',
            renderDate: 'RenderDate',
            renderStatus: 'RenderStatus',
            sendDate: 'SendDate',
            sendStatus: 'SendStatus',
            smsContent: 'SmsContent',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            errCode: 'string',
            outId: 'string',
            phoneNumber: 'string',
            receiveDate: 'string',
            receiveType: 'string',
            renderDate: 'string',
            renderStatus: 'number',
            sendDate: 'string',
            sendStatus: 'number',
            smsContent: 'string',
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCardSmsDetailsResponseBodyCardSendDetailDTORecords = GetCardSmsDetailsResponseBodyCardSendDetailDTORecords;
class GetCardSmsDetailsResponseBodyCardSendDetailDTO extends $dara.Model {
    static names() {
        return {
            currentPage: 'CurrentPage',
            pageSize: 'PageSize',
            records: 'Records',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            pageSize: 'number',
            records: { 'type': 'array', 'itemType': GetCardSmsDetailsResponseBodyCardSendDetailDTORecords },
            totalCount: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.records)) {
            $dara.Model.validateArray(this.records);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCardSmsDetailsResponseBodyCardSendDetailDTO = GetCardSmsDetailsResponseBodyCardSendDetailDTO;
class GetCardSmsLinkResponseBodyData extends $dara.Model {
    static names() {
        return {
            cardPhoneNumbers: 'CardPhoneNumbers',
            cardSignNames: 'CardSignNames',
            cardSmsLinks: 'CardSmsLinks',
            cardTmpState: 'CardTmpState',
            notMediaMobiles: 'NotMediaMobiles',
        };
    }
    static types() {
        return {
            cardPhoneNumbers: 'string',
            cardSignNames: 'string',
            cardSmsLinks: 'string',
            cardTmpState: 'number',
            notMediaMobiles: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCardSmsLinkResponseBodyData = GetCardSmsLinkResponseBodyData;
class GetMediaResourceIdResponseBodyData extends $dara.Model {
    static names() {
        return {
            resUrlDownload: 'ResUrlDownload',
            resourceId: 'ResourceId',
        };
    }
    static types() {
        return {
            resUrlDownload: 'string',
            resourceId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMediaResourceIdResponseBodyData = GetMediaResourceIdResponseBodyData;
class GetOSSInfoForCardTemplateResponseBodyData extends $dara.Model {
    static names() {
        return {
            accessKeyId: 'AccessKeyId',
            aliUid: 'AliUid',
            bucket: 'Bucket',
            expireTime: 'ExpireTime',
            host: 'Host',
            policy: 'Policy',
            signature: 'Signature',
            startPath: 'StartPath',
        };
    }
    static types() {
        return {
            accessKeyId: 'string',
            aliUid: 'string',
            bucket: 'string',
            expireTime: 'string',
            host: 'string',
            policy: 'string',
            signature: 'string',
            startPath: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOSSInfoForCardTemplateResponseBodyData = GetOSSInfoForCardTemplateResponseBodyData;
class GetOSSInfoForUploadFileResponseBodyModel extends $dara.Model {
    static names() {
        return {
            accessKeyId: 'AccessKeyId',
            expireTime: 'ExpireTime',
            host: 'Host',
            policy: 'Policy',
            signature: 'Signature',
            startPath: 'StartPath',
        };
    }
    static types() {
        return {
            accessKeyId: 'string',
            expireTime: 'string',
            host: 'string',
            policy: 'string',
            signature: 'string',
            startPath: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOSSInfoForUploadFileResponseBodyModel = GetOSSInfoForUploadFileResponseBodyModel;
class GetQualificationOssInfoResponseBodyData extends $dara.Model {
    static names() {
        return {
            accessKeyId: 'AccessKeyId',
            expire: 'Expire',
            host: 'Host',
            policy: 'Policy',
            signature: 'Signature',
            startPath: 'StartPath',
        };
    }
    static types() {
        return {
            accessKeyId: 'string',
            expire: 'number',
            host: 'string',
            policy: 'string',
            signature: 'string',
            startPath: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetQualificationOssInfoResponseBodyData = GetQualificationOssInfoResponseBodyData;
class GetSmsSignResponseBodyAuditInfo extends $dara.Model {
    static names() {
        return {
            auditDate: 'AuditDate',
            rejectInfo: 'RejectInfo',
        };
    }
    static types() {
        return {
            auditDate: 'string',
            rejectInfo: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsSignResponseBodyAuditInfo = GetSmsSignResponseBodyAuditInfo;
class GetSmsTemplateResponseBodyAuditInfo extends $dara.Model {
    static names() {
        return {
            auditDate: 'AuditDate',
            rejectInfo: 'RejectInfo',
        };
    }
    static types() {
        return {
            auditDate: 'string',
            rejectInfo: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsTemplateResponseBodyAuditInfo = GetSmsTemplateResponseBodyAuditInfo;
class GetSmsTemplateResponseBodyFileUrlList extends $dara.Model {
    static names() {
        return {
            fileUrl: 'FileUrl',
        };
    }
    static types() {
        return {
            fileUrl: { 'type': 'array', 'itemType': 'string' },
        };
    }
    validate() {
        if (Array.isArray(this.fileUrl)) {
            $dara.Model.validateArray(this.fileUrl);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsTemplateResponseBodyFileUrlList = GetSmsTemplateResponseBodyFileUrlList;
class GetSmsTemplateResponseBodyMoreDataFileUrlList extends $dara.Model {
    static names() {
        return {
            moreDataFileUrl: 'MoreDataFileUrl',
        };
    }
    static types() {
        return {
            moreDataFileUrl: { 'type': 'array', 'itemType': 'string' },
        };
    }
    validate() {
        if (Array.isArray(this.moreDataFileUrl)) {
            $dara.Model.validateArray(this.moreDataFileUrl);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsTemplateResponseBodyMoreDataFileUrlList = GetSmsTemplateResponseBodyMoreDataFileUrlList;
class ListTagResourcesRequestTag extends $dara.Model {
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTagResourcesRequestTag = ListTagResourcesRequestTag;
class ListTagResourcesResponseBodyTagResourcesTagResource extends $dara.Model {
    static names() {
        return {
            resourceId: 'ResourceId',
            resourceType: 'ResourceType',
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            resourceId: 'string',
            resourceType: 'string',
            tagKey: 'string',
            tagValue: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTagResourcesResponseBodyTagResourcesTagResource = ListTagResourcesResponseBodyTagResourcesTagResource;
class ListTagResourcesResponseBodyTagResources extends $dara.Model {
    static names() {
        return {
            tagResource: 'TagResource',
        };
    }
    static types() {
        return {
            tagResource: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResourcesTagResource },
        };
    }
    validate() {
        if (Array.isArray(this.tagResource)) {
            $dara.Model.validateArray(this.tagResource);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTagResourcesResponseBodyTagResources = ListTagResourcesResponseBodyTagResources;
class ModifySmsSignRequestSignFileList extends $dara.Model {
    static names() {
        return {
            fileContents: 'FileContents',
            fileSuffix: 'FileSuffix',
        };
    }
    static types() {
        return {
            fileContents: 'string',
            fileSuffix: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ModifySmsSignRequestSignFileList = ModifySmsSignRequestSignFileList;
class QueryCardSmsTemplateResponseBodyData extends $dara.Model {
    static names() {
        return {
            templates: 'Templates',
        };
    }
    static types() {
        return {
            templates: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
    validate() {
        if (Array.isArray(this.templates)) {
            $dara.Model.validateArray(this.templates);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCardSmsTemplateResponseBodyData = QueryCardSmsTemplateResponseBodyData;
class QueryCardSmsTemplateReportResponseBodyData extends $dara.Model {
    static names() {
        return {
            model: 'model',
        };
    }
    static types() {
        return {
            model: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
    validate() {
        if (Array.isArray(this.model)) {
            $dara.Model.validateArray(this.model);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCardSmsTemplateReportResponseBodyData = QueryCardSmsTemplateReportResponseBodyData;
class QueryExtCodeSignResponseBodyDataList extends $dara.Model {
    static names() {
        return {
            active: 'Active',
            extCode: 'ExtCode',
            sendCount: 'SendCount',
            signName: 'SignName',
            source: 'Source',
        };
    }
    static types() {
        return {
            active: 'number',
            extCode: 'string',
            sendCount: 'number',
            signName: 'string',
            source: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryExtCodeSignResponseBodyDataList = QueryExtCodeSignResponseBodyDataList;
class QueryExtCodeSignResponseBodyData extends $dara.Model {
    static names() {
        return {
            list: 'List',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': QueryExtCodeSignResponseBodyDataList },
            pageNo: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.list)) {
            $dara.Model.validateArray(this.list);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryExtCodeSignResponseBodyData = QueryExtCodeSignResponseBodyData;
class QueryMobilesCardSupportResponseBodyDataQueryResult extends $dara.Model {
    static names() {
        return {
            mobile: 'Mobile',
            support: 'Support',
        };
    }
    static types() {
        return {
            mobile: 'string',
            support: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMobilesCardSupportResponseBodyDataQueryResult = QueryMobilesCardSupportResponseBodyDataQueryResult;
class QueryMobilesCardSupportResponseBodyData extends $dara.Model {
    static names() {
        return {
            queryResult: 'QueryResult',
        };
    }
    static types() {
        return {
            queryResult: { 'type': 'array', 'itemType': QueryMobilesCardSupportResponseBodyDataQueryResult },
        };
    }
    validate() {
        if (Array.isArray(this.queryResult)) {
            $dara.Model.validateArray(this.queryResult);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMobilesCardSupportResponseBodyData = QueryMobilesCardSupportResponseBodyData;
class QueryPageSmartShortUrlLogResponseBodyModelList extends $dara.Model {
    static names() {
        return {
            clickState: 'ClickState',
            clickTime: 'ClickTime',
            createTime: 'CreateTime',
            phoneNumber: 'PhoneNumber',
            shortName: 'ShortName',
            shortUrl: 'ShortUrl',
        };
    }
    static types() {
        return {
            clickState: 'number',
            clickTime: 'number',
            createTime: 'number',
            phoneNumber: 'string',
            shortName: 'string',
            shortUrl: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPageSmartShortUrlLogResponseBodyModelList = QueryPageSmartShortUrlLogResponseBodyModelList;
class QueryPageSmartShortUrlLogResponseBodyModel extends $dara.Model {
    static names() {
        return {
            list: 'List',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
            totalPage: 'TotalPage',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': QueryPageSmartShortUrlLogResponseBodyModelList },
            pageNo: 'number',
            pageSize: 'number',
            totalCount: 'number',
            totalPage: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.list)) {
            $dara.Model.validateArray(this.list);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPageSmartShortUrlLogResponseBodyModel = QueryPageSmartShortUrlLogResponseBodyModel;
class QuerySendDetailsResponseBodySmsSendDetailDTOsSmsSendDetailDTO extends $dara.Model {
    static names() {
        return {
            content: 'Content',
            errCode: 'ErrCode',
            outId: 'OutId',
            phoneNum: 'PhoneNum',
            receiveDate: 'ReceiveDate',
            sendDate: 'SendDate',
            sendStatus: 'SendStatus',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            content: 'string',
            errCode: 'string',
            outId: 'string',
            phoneNum: 'string',
            receiveDate: 'string',
            sendDate: 'string',
            sendStatus: 'number',
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendDetailsResponseBodySmsSendDetailDTOsSmsSendDetailDTO = QuerySendDetailsResponseBodySmsSendDetailDTOsSmsSendDetailDTO;
class QuerySendDetailsResponseBodySmsSendDetailDTOs extends $dara.Model {
    static names() {
        return {
            smsSendDetailDTO: 'SmsSendDetailDTO',
        };
    }
    static types() {
        return {
            smsSendDetailDTO: { 'type': 'array', 'itemType': QuerySendDetailsResponseBodySmsSendDetailDTOsSmsSendDetailDTO },
        };
    }
    validate() {
        if (Array.isArray(this.smsSendDetailDTO)) {
            $dara.Model.validateArray(this.smsSendDetailDTO);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendDetailsResponseBodySmsSendDetailDTOs = QuerySendDetailsResponseBodySmsSendDetailDTOs;
class QuerySendStatisticsResponseBodyDataTargetList extends $dara.Model {
    static names() {
        return {
            noRespondedCount: 'NoRespondedCount',
            respondedFailCount: 'RespondedFailCount',
            respondedSuccessCount: 'RespondedSuccessCount',
            sendDate: 'SendDate',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            noRespondedCount: 'number',
            respondedFailCount: 'number',
            respondedSuccessCount: 'number',
            sendDate: 'string',
            totalCount: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendStatisticsResponseBodyDataTargetList = QuerySendStatisticsResponseBodyDataTargetList;
class QuerySendStatisticsResponseBodyData extends $dara.Model {
    static names() {
        return {
            targetList: 'TargetList',
            totalSize: 'TotalSize',
        };
    }
    static types() {
        return {
            targetList: { 'type': 'array', 'itemType': QuerySendStatisticsResponseBodyDataTargetList },
            totalSize: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.targetList)) {
            $dara.Model.validateArray(this.targetList);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendStatisticsResponseBodyData = QuerySendStatisticsResponseBodyData;
class QueryShortUrlResponseBodyData extends $dara.Model {
    static names() {
        return {
            createDate: 'CreateDate',
            expireDate: 'ExpireDate',
            pageViewCount: 'PageViewCount',
            shortUrl: 'ShortUrl',
            shortUrlName: 'ShortUrlName',
            shortUrlStatus: 'ShortUrlStatus',
            sourceUrl: 'SourceUrl',
            uniqueVisitorCount: 'UniqueVisitorCount',
        };
    }
    static types() {
        return {
            createDate: 'string',
            expireDate: 'string',
            pageViewCount: 'string',
            shortUrl: 'string',
            shortUrlName: 'string',
            shortUrlStatus: 'string',
            sourceUrl: 'string',
            uniqueVisitorCount: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryShortUrlResponseBodyData = QueryShortUrlResponseBodyData;
class QuerySingleSmsQualificationResponseBodyDataBusinessLicensePics extends $dara.Model {
    static names() {
        return {
            licensePic: 'LicensePic',
            picUrl: 'PicUrl',
            type: 'Type',
        };
    }
    static types() {
        return {
            licensePic: 'string',
            picUrl: 'string',
            type: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleSmsQualificationResponseBodyDataBusinessLicensePics = QuerySingleSmsQualificationResponseBodyDataBusinessLicensePics;
class QuerySingleSmsQualificationResponseBodyDataOtherFiles extends $dara.Model {
    static names() {
        return {
            licensePic: 'LicensePic',
            picUrl: 'PicUrl',
        };
    }
    static types() {
        return {
            licensePic: 'string',
            picUrl: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleSmsQualificationResponseBodyDataOtherFiles = QuerySingleSmsQualificationResponseBodyDataOtherFiles;
class QuerySingleSmsQualificationResponseBodyData extends $dara.Model {
    static names() {
        return {
            adminIDCardExpDate: 'AdminIDCardExpDate',
            adminIDCardFrontFace: 'AdminIDCardFrontFace',
            adminIDCardNo: 'AdminIDCardNo',
            adminIDCardPic: 'AdminIDCardPic',
            adminIDCardType: 'AdminIDCardType',
            adminName: 'AdminName',
            adminPhoneNo: 'AdminPhoneNo',
            businessLicensePics: 'BusinessLicensePics',
            businessType: 'BusinessType',
            companyName: 'CompanyName',
            companyType: 'CompanyType',
            effTimeStr: 'EffTimeStr',
            legalPersonIDCardNo: 'LegalPersonIDCardNo',
            legalPersonIDCardType: 'LegalPersonIDCardType',
            legalPersonIdCardEffTime: 'LegalPersonIdCardEffTime',
            legalPersonName: 'LegalPersonName',
            organizationCode: 'OrganizationCode',
            otherFiles: 'OtherFiles',
            qualificationGroupId: 'QualificationGroupId',
            qualificationName: 'QualificationName',
            remark: 'Remark',
            state: 'State',
            useBySelf: 'UseBySelf',
            whetherShare: 'WhetherShare',
            workOrderId: 'WorkOrderId',
        };
    }
    static types() {
        return {
            adminIDCardExpDate: 'string',
            adminIDCardFrontFace: 'string',
            adminIDCardNo: 'string',
            adminIDCardPic: 'string',
            adminIDCardType: 'string',
            adminName: 'string',
            adminPhoneNo: 'string',
            businessLicensePics: { 'type': 'array', 'itemType': QuerySingleSmsQualificationResponseBodyDataBusinessLicensePics },
            businessType: 'string',
            companyName: 'string',
            companyType: 'string',
            effTimeStr: 'string',
            legalPersonIDCardNo: 'string',
            legalPersonIDCardType: 'string',
            legalPersonIdCardEffTime: 'string',
            legalPersonName: 'string',
            organizationCode: 'string',
            otherFiles: { 'type': 'array', 'itemType': QuerySingleSmsQualificationResponseBodyDataOtherFiles },
            qualificationGroupId: 'number',
            qualificationName: 'string',
            remark: 'string',
            state: 'string',
            useBySelf: 'boolean',
            whetherShare: 'boolean',
            workOrderId: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.businessLicensePics)) {
            $dara.Model.validateArray(this.businessLicensePics);
        }
        if (Array.isArray(this.otherFiles)) {
            $dara.Model.validateArray(this.otherFiles);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleSmsQualificationResponseBodyData = QuerySingleSmsQualificationResponseBodyData;
class QuerySmsAuthorizationLetterResponseBodyData extends $dara.Model {
    static names() {
        return {
            authorization: 'Authorization',
            authorizationLetterExpDate: 'AuthorizationLetterExpDate',
            authorizationLetterId: 'AuthorizationLetterId',
            authorizationLetterName: 'AuthorizationLetterName',
            authorizationLetterPic: 'AuthorizationLetterPic',
            organizationCode: 'OrganizationCode',
            proxyAuthorization: 'ProxyAuthorization',
            signScope: 'SignScope',
            state: 'State',
            status: 'Status',
        };
    }
    static types() {
        return {
            authorization: 'string',
            authorizationLetterExpDate: 'string',
            authorizationLetterId: 'number',
            authorizationLetterName: 'string',
            authorizationLetterPic: 'string',
            organizationCode: 'string',
            proxyAuthorization: 'string',
            signScope: 'string',
            state: 'string',
            status: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsAuthorizationLetterResponseBodyData = QuerySmsAuthorizationLetterResponseBodyData;
class QuerySmsQualificationRecordResponseBodyDataList extends $dara.Model {
    static names() {
        return {
            auditRemark: 'AuditRemark',
            auditTime: 'AuditTime',
            companyName: 'CompanyName',
            createDate: 'CreateDate',
            groupId: 'GroupId',
            legalPersonName: 'LegalPersonName',
            qualificationGroupName: 'QualificationGroupName',
            stateName: 'StateName',
            useBySelf: 'UseBySelf',
            workOrderId: 'WorkOrderId',
        };
    }
    static types() {
        return {
            auditRemark: 'string',
            auditTime: 'string',
            companyName: 'string',
            createDate: 'string',
            groupId: 'number',
            legalPersonName: 'string',
            qualificationGroupName: 'string',
            stateName: 'string',
            useBySelf: 'string',
            workOrderId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsQualificationRecordResponseBodyDataList = QuerySmsQualificationRecordResponseBodyDataList;
class QuerySmsQualificationRecordResponseBodyData extends $dara.Model {
    static names() {
        return {
            list: 'List',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': QuerySmsQualificationRecordResponseBodyDataList },
            pageNo: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.list)) {
            $dara.Model.validateArray(this.list);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsQualificationRecordResponseBodyData = QuerySmsQualificationRecordResponseBodyData;
class QuerySmsSignListResponseBodySmsSignListReason extends $dara.Model {
    static names() {
        return {
            rejectDate: 'RejectDate',
            rejectInfo: 'RejectInfo',
            rejectSubInfo: 'RejectSubInfo',
        };
    }
    static types() {
        return {
            rejectDate: 'string',
            rejectInfo: 'string',
            rejectSubInfo: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsSignListResponseBodySmsSignListReason = QuerySmsSignListResponseBodySmsSignListReason;
class QuerySmsSignListResponseBodySmsSignList extends $dara.Model {
    static names() {
        return {
            auditStatus: 'AuditStatus',
            authorizationLetterId: 'AuthorizationLetterId',
            businessType: 'BusinessType',
            createDate: 'CreateDate',
            orderId: 'OrderId',
            reason: 'Reason',
            signName: 'SignName',
            authorizationLetterAuditPass: 'authorizationLetterAuditPass',
        };
    }
    static types() {
        return {
            auditStatus: 'string',
            authorizationLetterId: 'number',
            businessType: 'string',
            createDate: 'string',
            orderId: 'string',
            reason: QuerySmsSignListResponseBodySmsSignListReason,
            signName: 'string',
            authorizationLetterAuditPass: 'boolean',
        };
    }
    validate() {
        if (this.reason && typeof this.reason.validate === 'function') {
            this.reason.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsSignListResponseBodySmsSignList = QuerySmsSignListResponseBodySmsSignList;
class QuerySmsTemplateListResponseBodySmsTemplateListReason extends $dara.Model {
    static names() {
        return {
            rejectDate: 'RejectDate',
            rejectInfo: 'RejectInfo',
            rejectSubInfo: 'RejectSubInfo',
        };
    }
    static types() {
        return {
            rejectDate: 'string',
            rejectInfo: 'string',
            rejectSubInfo: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsTemplateListResponseBodySmsTemplateListReason = QuerySmsTemplateListResponseBodySmsTemplateListReason;
class QuerySmsTemplateListResponseBodySmsTemplateList extends $dara.Model {
    static names() {
        return {
            auditStatus: 'AuditStatus',
            createDate: 'CreateDate',
            orderId: 'OrderId',
            outerTemplateType: 'OuterTemplateType',
            reason: 'Reason',
            templateCode: 'TemplateCode',
            templateContent: 'TemplateContent',
            templateName: 'TemplateName',
            templateType: 'TemplateType',
        };
    }
    static types() {
        return {
            auditStatus: 'string',
            createDate: 'string',
            orderId: 'string',
            outerTemplateType: 'number',
            reason: QuerySmsTemplateListResponseBodySmsTemplateListReason,
            templateCode: 'string',
            templateContent: 'string',
            templateName: 'string',
            templateType: 'number',
        };
    }
    validate() {
        if (this.reason && typeof this.reason.validate === 'function') {
            this.reason.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsTemplateListResponseBodySmsTemplateList = QuerySmsTemplateListResponseBodySmsTemplateList;
class SendBatchCardSmsResponseBodyData extends $dara.Model {
    static names() {
        return {
            bizCardId: 'BizCardId',
            bizDigitalId: 'BizDigitalId',
            bizSmsId: 'BizSmsId',
            cardTmpState: 'CardTmpState',
            mediaMobiles: 'MediaMobiles',
            notMediaMobiles: 'NotMediaMobiles',
        };
    }
    static types() {
        return {
            bizCardId: 'string',
            bizDigitalId: 'string',
            bizSmsId: 'string',
            cardTmpState: 'number',
            mediaMobiles: 'string',
            notMediaMobiles: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendBatchCardSmsResponseBodyData = SendBatchCardSmsResponseBodyData;
class SendCardSmsRequestCardObjects extends $dara.Model {
    static names() {
        return {
            customUrl: 'customUrl',
            dyncParams: 'dyncParams',
            mobile: 'mobile',
        };
    }
    static types() {
        return {
            customUrl: 'string',
            dyncParams: 'string',
            mobile: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendCardSmsRequestCardObjects = SendCardSmsRequestCardObjects;
class SendCardSmsResponseBodyData extends $dara.Model {
    static names() {
        return {
            bizCardId: 'BizCardId',
            bizDigitalId: 'BizDigitalId',
            bizSmsId: 'BizSmsId',
            cardTmpState: 'CardTmpState',
            mediaMobiles: 'MediaMobiles',
            notMediaMobiles: 'NotMediaMobiles',
        };
    }
    static types() {
        return {
            bizCardId: 'string',
            bizDigitalId: 'string',
            bizSmsId: 'string',
            cardTmpState: 'number',
            mediaMobiles: 'string',
            notMediaMobiles: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendCardSmsResponseBodyData = SendCardSmsResponseBodyData;
class SubmitSmsQualificationRequestBusinessLicensePics extends $dara.Model {
    static names() {
        return {
            licensePic: 'LicensePic',
            type: 'Type',
        };
    }
    static types() {
        return {
            licensePic: 'string',
            type: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitSmsQualificationRequestBusinessLicensePics = SubmitSmsQualificationRequestBusinessLicensePics;
class SubmitSmsQualificationRequestOtherFiles extends $dara.Model {
    static names() {
        return {
            licensePic: 'LicensePic',
        };
    }
    static types() {
        return {
            licensePic: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitSmsQualificationRequestOtherFiles = SubmitSmsQualificationRequestOtherFiles;
class TagResourcesRequestTag extends $dara.Model {
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.TagResourcesRequestTag = TagResourcesRequestTag;
class UpdateSmsQualificationRequestBusinessLicensePics extends $dara.Model {
    static names() {
        return {
            licensePic: 'LicensePic',
            type: 'Type',
        };
    }
    static types() {
        return {
            licensePic: 'string',
            type: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsQualificationRequestBusinessLicensePics = UpdateSmsQualificationRequestBusinessLicensePics;
class UpdateSmsQualificationRequestOtherFiles extends $dara.Model {
    static names() {
        return {
            licensePic: 'LicensePic',
        };
    }
    static types() {
        return {
            licensePic: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsQualificationRequestOtherFiles = UpdateSmsQualificationRequestOtherFiles;
class AddExtCodeSignRequest extends $dara.Model {
    static names() {
        return {
            extCode: 'ExtCode',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            extCode: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddExtCodeSignRequest = AddExtCodeSignRequest;
class AddExtCodeSignResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddExtCodeSignResponseBody = AddExtCodeSignResponseBody;
class AddExtCodeSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddExtCodeSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddExtCodeSignResponse = AddExtCodeSignResponse;
class AddShortUrlRequest extends $dara.Model {
    static names() {
        return {
            effectiveDays: 'EffectiveDays',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            shortUrlName: 'ShortUrlName',
            sourceUrl: 'SourceUrl',
        };
    }
    static types() {
        return {
            effectiveDays: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            shortUrlName: 'string',
            sourceUrl: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddShortUrlRequest = AddShortUrlRequest;
class AddShortUrlResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: AddShortUrlResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddShortUrlResponseBody = AddShortUrlResponseBody;
class AddShortUrlResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddShortUrlResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddShortUrlResponse = AddShortUrlResponse;
class AddSmsSignRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signFileList: 'SignFileList',
            signName: 'SignName',
            signSource: 'SignSource',
            signType: 'SignType',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signFileList: { 'type': 'array', 'itemType': AddSmsSignRequestSignFileList },
            signName: 'string',
            signSource: 'number',
            signType: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.signFileList)) {
            $dara.Model.validateArray(this.signFileList);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddSmsSignRequest = AddSmsSignRequest;
class AddSmsSignResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddSmsSignResponseBody = AddSmsSignResponseBody;
class AddSmsSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddSmsSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddSmsSignResponse = AddSmsSignResponse;
class AddSmsTemplateRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateContent: 'TemplateContent',
            templateName: 'TemplateName',
            templateType: 'TemplateType',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateContent: 'string',
            templateName: 'string',
            templateType: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddSmsTemplateRequest = AddSmsTemplateRequest;
class AddSmsTemplateResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddSmsTemplateResponseBody = AddSmsTemplateResponseBody;
class AddSmsTemplateResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddSmsTemplateResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.AddSmsTemplateResponse = AddSmsTemplateResponse;
class ChangeSignatureQualificationRequest extends $dara.Model {
    static names() {
        return {
            authorizationLetterId: 'AuthorizationLetterId',
            ownerId: 'OwnerId',
            qualificationId: 'QualificationId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signatureName: 'SignatureName',
        };
    }
    static types() {
        return {
            authorizationLetterId: 'number',
            ownerId: 'number',
            qualificationId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signatureName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ChangeSignatureQualificationRequest = ChangeSignatureQualificationRequest;
class ChangeSignatureQualificationResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: ChangeSignatureQualificationResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ChangeSignatureQualificationResponseBody = ChangeSignatureQualificationResponseBody;
class ChangeSignatureQualificationResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ChangeSignatureQualificationResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ChangeSignatureQualificationResponse = ChangeSignatureQualificationResponse;
class CheckMobilesCardSupportRequest extends $dara.Model {
    static names() {
        return {
            mobiles: 'Mobiles',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            mobiles: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
            templateCode: 'string',
        };
    }
    validate() {
        if (Array.isArray(this.mobiles)) {
            $dara.Model.validateArray(this.mobiles);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckMobilesCardSupportRequest = CheckMobilesCardSupportRequest;
class CheckMobilesCardSupportResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CheckMobilesCardSupportResponseBodyData,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckMobilesCardSupportResponseBody = CheckMobilesCardSupportResponseBody;
class CheckMobilesCardSupportResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckMobilesCardSupportResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckMobilesCardSupportResponse = CheckMobilesCardSupportResponse;
class ConversionDataIntlRequest extends $dara.Model {
    static names() {
        return {
            conversionRate: 'ConversionRate',
            ownerId: 'OwnerId',
            reportTime: 'ReportTime',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            conversionRate: 'string',
            ownerId: 'number',
            reportTime: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversionDataIntlRequest = ConversionDataIntlRequest;
class ConversionDataIntlResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversionDataIntlResponseBody = ConversionDataIntlResponseBody;
class ConversionDataIntlResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ConversionDataIntlResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversionDataIntlResponse = ConversionDataIntlResponse;
class CreateCardSmsTemplateRequest extends $dara.Model {
    static names() {
        return {
            factorys: 'Factorys',
            memo: 'Memo',
            template: 'Template',
            templateName: 'TemplateName',
        };
    }
    static types() {
        return {
            factorys: 'string',
            memo: 'string',
            template: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            templateName: 'string',
        };
    }
    validate() {
        if (this.template) {
            $dara.Model.validateMap(this.template);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCardSmsTemplateRequest = CreateCardSmsTemplateRequest;
class CreateCardSmsTemplateShrinkRequest extends $dara.Model {
    static names() {
        return {
            factorys: 'Factorys',
            memo: 'Memo',
            templateShrink: 'Template',
            templateName: 'TemplateName',
        };
    }
    static types() {
        return {
            factorys: 'string',
            memo: 'string',
            templateShrink: 'string',
            templateName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCardSmsTemplateShrinkRequest = CreateCardSmsTemplateShrinkRequest;
class CreateCardSmsTemplateResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateCardSmsTemplateResponseBodyData,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCardSmsTemplateResponseBody = CreateCardSmsTemplateResponseBody;
class CreateCardSmsTemplateResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateCardSmsTemplateResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCardSmsTemplateResponse = CreateCardSmsTemplateResponse;
class CreateSmartShortUrlRequest extends $dara.Model {
    static names() {
        return {
            outId: 'OutId',
            ownerId: 'OwnerId',
            phoneNumbers: 'PhoneNumbers',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sourceUrl: 'SourceUrl',
        };
    }
    static types() {
        return {
            outId: 'string',
            ownerId: 'number',
            phoneNumbers: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sourceUrl: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmartShortUrlRequest = CreateSmartShortUrlRequest;
class CreateSmartShortUrlResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            model: 'Model',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            model: { 'type': 'array', 'itemType': CreateSmartShortUrlResponseBodyModel },
            requestId: 'string',
        };
    }
    validate() {
        if (Array.isArray(this.model)) {
            $dara.Model.validateArray(this.model);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmartShortUrlResponseBody = CreateSmartShortUrlResponseBody;
class CreateSmartShortUrlResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSmartShortUrlResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmartShortUrlResponse = CreateSmartShortUrlResponse;
class CreateSmsAuthorizationLetterRequest extends $dara.Model {
    static names() {
        return {
            authorization: 'Authorization',
            authorizationLetterExpDate: 'AuthorizationLetterExpDate',
            authorizationLetterName: 'AuthorizationLetterName',
            authorizationLetterPic: 'AuthorizationLetterPic',
            organizationCode: 'OrganizationCode',
            ownerId: 'OwnerId',
            proxyAuthorization: 'ProxyAuthorization',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signList: 'SignList',
        };
    }
    static types() {
        return {
            authorization: 'string',
            authorizationLetterExpDate: 'string',
            authorizationLetterName: 'string',
            authorizationLetterPic: 'string',
            organizationCode: 'string',
            ownerId: 'number',
            proxyAuthorization: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    validate() {
        if (Array.isArray(this.signList)) {
            $dara.Model.validateArray(this.signList);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsAuthorizationLetterRequest = CreateSmsAuthorizationLetterRequest;
class CreateSmsAuthorizationLetterShrinkRequest extends $dara.Model {
    static names() {
        return {
            authorization: 'Authorization',
            authorizationLetterExpDate: 'AuthorizationLetterExpDate',
            authorizationLetterName: 'AuthorizationLetterName',
            authorizationLetterPic: 'AuthorizationLetterPic',
            organizationCode: 'OrganizationCode',
            ownerId: 'OwnerId',
            proxyAuthorization: 'ProxyAuthorization',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signListShrink: 'SignList',
        };
    }
    static types() {
        return {
            authorization: 'string',
            authorizationLetterExpDate: 'string',
            authorizationLetterName: 'string',
            authorizationLetterPic: 'string',
            organizationCode: 'string',
            ownerId: 'number',
            proxyAuthorization: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signListShrink: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsAuthorizationLetterShrinkRequest = CreateSmsAuthorizationLetterShrinkRequest;
class CreateSmsAuthorizationLetterResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsAuthorizationLetterResponseBody = CreateSmsAuthorizationLetterResponseBody;
class CreateSmsAuthorizationLetterResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSmsAuthorizationLetterResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsAuthorizationLetterResponse = CreateSmsAuthorizationLetterResponse;
class CreateSmsSignRequest extends $dara.Model {
    static names() {
        return {
            applySceneContent: 'ApplySceneContent',
            authorizationLetterId: 'AuthorizationLetterId',
            moreData: 'MoreData',
            ownerId: 'OwnerId',
            qualificationId: 'QualificationId',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
            signSource: 'SignSource',
            signType: 'SignType',
            thirdParty: 'ThirdParty',
        };
    }
    static types() {
        return {
            applySceneContent: 'string',
            authorizationLetterId: 'number',
            moreData: { 'type': 'array', 'itemType': 'string' },
            ownerId: 'number',
            qualificationId: 'number',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
            signSource: 'number',
            signType: 'number',
            thirdParty: 'boolean',
        };
    }
    validate() {
        if (Array.isArray(this.moreData)) {
            $dara.Model.validateArray(this.moreData);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsSignRequest = CreateSmsSignRequest;
class CreateSmsSignShrinkRequest extends $dara.Model {
    static names() {
        return {
            applySceneContent: 'ApplySceneContent',
            authorizationLetterId: 'AuthorizationLetterId',
            moreDataShrink: 'MoreData',
            ownerId: 'OwnerId',
            qualificationId: 'QualificationId',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
            signSource: 'SignSource',
            signType: 'SignType',
            thirdParty: 'ThirdParty',
        };
    }
    static types() {
        return {
            applySceneContent: 'string',
            authorizationLetterId: 'number',
            moreDataShrink: 'string',
            ownerId: 'number',
            qualificationId: 'number',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
            signSource: 'number',
            signType: 'number',
            thirdParty: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsSignShrinkRequest = CreateSmsSignShrinkRequest;
class CreateSmsSignResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            orderId: 'OrderId',
            requestId: 'RequestId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            orderId: 'string',
            requestId: 'string',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsSignResponseBody = CreateSmsSignResponseBody;
class CreateSmsSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSmsSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsSignResponse = CreateSmsSignResponse;
class CreateSmsTemplateRequest extends $dara.Model {
    static names() {
        return {
            applySceneContent: 'ApplySceneContent',
            intlType: 'IntlType',
            moreData: 'MoreData',
            ownerId: 'OwnerId',
            relatedSignName: 'RelatedSignName',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateContent: 'TemplateContent',
            templateName: 'TemplateName',
            templateRule: 'TemplateRule',
            templateType: 'TemplateType',
        };
    }
    static types() {
        return {
            applySceneContent: 'string',
            intlType: 'number',
            moreData: { 'type': 'array', 'itemType': 'string' },
            ownerId: 'number',
            relatedSignName: 'string',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateContent: 'string',
            templateName: 'string',
            templateRule: 'string',
            templateType: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.moreData)) {
            $dara.Model.validateArray(this.moreData);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsTemplateRequest = CreateSmsTemplateRequest;
class CreateSmsTemplateShrinkRequest extends $dara.Model {
    static names() {
        return {
            applySceneContent: 'ApplySceneContent',
            intlType: 'IntlType',
            moreDataShrink: 'MoreData',
            ownerId: 'OwnerId',
            relatedSignName: 'RelatedSignName',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateContent: 'TemplateContent',
            templateName: 'TemplateName',
            templateRule: 'TemplateRule',
            templateType: 'TemplateType',
        };
    }
    static types() {
        return {
            applySceneContent: 'string',
            intlType: 'number',
            moreDataShrink: 'string',
            ownerId: 'number',
            relatedSignName: 'string',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateContent: 'string',
            templateName: 'string',
            templateRule: 'string',
            templateType: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsTemplateShrinkRequest = CreateSmsTemplateShrinkRequest;
class CreateSmsTemplateResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            orderId: 'OrderId',
            requestId: 'RequestId',
            templateCode: 'TemplateCode',
            templateName: 'TemplateName',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            orderId: 'string',
            requestId: 'string',
            templateCode: 'string',
            templateName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsTemplateResponseBody = CreateSmsTemplateResponseBody;
class CreateSmsTemplateResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSmsTemplateResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSmsTemplateResponse = CreateSmsTemplateResponse;
class DeleteExtCodeSignRequest extends $dara.Model {
    static names() {
        return {
            extCode: 'ExtCode',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            extCode: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteExtCodeSignRequest = DeleteExtCodeSignRequest;
class DeleteExtCodeSignResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteExtCodeSignResponseBody = DeleteExtCodeSignResponseBody;
class DeleteExtCodeSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteExtCodeSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteExtCodeSignResponse = DeleteExtCodeSignResponse;
class DeleteShortUrlRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sourceUrl: 'SourceUrl',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sourceUrl: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteShortUrlRequest = DeleteShortUrlRequest;
class DeleteShortUrlResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteShortUrlResponseBody = DeleteShortUrlResponseBody;
class DeleteShortUrlResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteShortUrlResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteShortUrlResponse = DeleteShortUrlResponse;
class DeleteSmsQualificationRequest extends $dara.Model {
    static names() {
        return {
            orderId: 'OrderId',
            ownerId: 'OwnerId',
            qualificationGroupId: 'QualificationGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            orderId: 'number',
            ownerId: 'number',
            qualificationGroupId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSmsQualificationRequest = DeleteSmsQualificationRequest;
class DeleteSmsQualificationResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSmsQualificationResponseBody = DeleteSmsQualificationResponseBody;
class DeleteSmsQualificationResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSmsQualificationResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSmsQualificationResponse = DeleteSmsQualificationResponse;
class DeleteSmsSignRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSmsSignRequest = DeleteSmsSignRequest;
class DeleteSmsSignResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSmsSignResponseBody = DeleteSmsSignResponseBody;
class DeleteSmsSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSmsSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSmsSignResponse = DeleteSmsSignResponse;
class DeleteSmsTemplateRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSmsTemplateRequest = DeleteSmsTemplateRequest;
class DeleteSmsTemplateResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSmsTemplateResponseBody = DeleteSmsTemplateResponseBody;
class DeleteSmsTemplateResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSmsTemplateResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSmsTemplateResponse = DeleteSmsTemplateResponse;
class GetCardSmsDetailsRequest extends $dara.Model {
    static names() {
        return {
            bizCardId: 'BizCardId',
            bizDigitId: 'BizDigitId',
            bizSmsId: 'BizSmsId',
            currentPage: 'CurrentPage',
            ownerId: 'OwnerId',
            pageSize: 'PageSize',
            phoneNumber: 'PhoneNumber',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sendDate: 'SendDate',
        };
    }
    static types() {
        return {
            bizCardId: 'string',
            bizDigitId: 'string',
            bizSmsId: 'string',
            currentPage: 'number',
            ownerId: 'number',
            pageSize: 'number',
            phoneNumber: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sendDate: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCardSmsDetailsRequest = GetCardSmsDetailsRequest;
class GetCardSmsDetailsResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            cardSendDetailDTO: 'CardSendDetailDTO',
            code: 'Code',
            message: 'Message',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            cardSendDetailDTO: GetCardSmsDetailsResponseBodyCardSendDetailDTO,
            code: 'string',
            message: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.cardSendDetailDTO && typeof this.cardSendDetailDTO.validate === 'function') {
            this.cardSendDetailDTO.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCardSmsDetailsResponseBody = GetCardSmsDetailsResponseBody;
class GetCardSmsDetailsResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCardSmsDetailsResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCardSmsDetailsResponse = GetCardSmsDetailsResponse;
class GetCardSmsLinkRequest extends $dara.Model {
    static names() {
        return {
            cardCodeType: 'CardCodeType',
            cardLinkType: 'CardLinkType',
            cardTemplateCode: 'CardTemplateCode',
            cardTemplateParamJson: 'CardTemplateParamJson',
            customShortCodeJson: 'CustomShortCodeJson',
            domain: 'Domain',
            outId: 'OutId',
            phoneNumberJson: 'PhoneNumberJson',
            signNameJson: 'SignNameJson',
        };
    }
    static types() {
        return {
            cardCodeType: 'number',
            cardLinkType: 'number',
            cardTemplateCode: 'string',
            cardTemplateParamJson: 'string',
            customShortCodeJson: 'string',
            domain: 'string',
            outId: 'string',
            phoneNumberJson: 'string',
            signNameJson: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCardSmsLinkRequest = GetCardSmsLinkRequest;
class GetCardSmsLinkResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetCardSmsLinkResponseBodyData,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCardSmsLinkResponseBody = GetCardSmsLinkResponseBody;
class GetCardSmsLinkResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCardSmsLinkResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCardSmsLinkResponse = GetCardSmsLinkResponse;
class GetMediaResourceIdRequest extends $dara.Model {
    static names() {
        return {
            extendInfo: 'ExtendInfo',
            fileSize: 'FileSize',
            memo: 'Memo',
            ossKey: 'OssKey',
            resourceType: 'ResourceType',
        };
    }
    static types() {
        return {
            extendInfo: 'string',
            fileSize: 'number',
            memo: 'string',
            ossKey: 'string',
            resourceType: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMediaResourceIdRequest = GetMediaResourceIdRequest;
class GetMediaResourceIdResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetMediaResourceIdResponseBodyData,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMediaResourceIdResponseBody = GetMediaResourceIdResponseBody;
class GetMediaResourceIdResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetMediaResourceIdResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMediaResourceIdResponse = GetMediaResourceIdResponse;
class GetOSSInfoForCardTemplateResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetOSSInfoForCardTemplateResponseBodyData,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOSSInfoForCardTemplateResponseBody = GetOSSInfoForCardTemplateResponseBody;
class GetOSSInfoForCardTemplateResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetOSSInfoForCardTemplateResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOSSInfoForCardTemplateResponse = GetOSSInfoForCardTemplateResponse;
class GetOSSInfoForUploadFileRequest extends $dara.Model {
    static names() {
        return {
            bizType: 'BizType',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOSSInfoForUploadFileRequest = GetOSSInfoForUploadFileRequest;
class GetOSSInfoForUploadFileResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            model: 'Model',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            model: GetOSSInfoForUploadFileResponseBodyModel,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.model && typeof this.model.validate === 'function') {
            this.model.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOSSInfoForUploadFileResponseBody = GetOSSInfoForUploadFileResponseBody;
class GetOSSInfoForUploadFileResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetOSSInfoForUploadFileResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOSSInfoForUploadFileResponse = GetOSSInfoForUploadFileResponse;
class GetQualificationOssInfoRequest extends $dara.Model {
    static names() {
        return {
            bizType: 'BizType',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetQualificationOssInfoRequest = GetQualificationOssInfoRequest;
class GetQualificationOssInfoResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: GetQualificationOssInfoResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetQualificationOssInfoResponseBody = GetQualificationOssInfoResponseBody;
class GetQualificationOssInfoResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetQualificationOssInfoResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetQualificationOssInfoResponse = GetQualificationOssInfoResponse;
class GetSmsSignRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsSignRequest = GetSmsSignRequest;
class GetSmsSignResponseBody extends $dara.Model {
    static names() {
        return {
            applyScene: 'ApplyScene',
            auditInfo: 'AuditInfo',
            authorizationLetterAuditPass: 'AuthorizationLetterAuditPass',
            authorizationLetterId: 'AuthorizationLetterId',
            code: 'Code',
            createDate: 'CreateDate',
            fileUrlList: 'FileUrlList',
            message: 'Message',
            orderId: 'OrderId',
            qualificationId: 'QualificationId',
            registerResult: 'RegisterResult',
            remark: 'Remark',
            requestId: 'RequestId',
            signCode: 'SignCode',
            signName: 'SignName',
            signStatus: 'SignStatus',
            signTag: 'SignTag',
            signUsage: 'SignUsage',
            thirdParty: 'ThirdParty',
        };
    }
    static types() {
        return {
            applyScene: 'string',
            auditInfo: GetSmsSignResponseBodyAuditInfo,
            authorizationLetterAuditPass: 'boolean',
            authorizationLetterId: 'number',
            code: 'string',
            createDate: 'string',
            fileUrlList: { 'type': 'array', 'itemType': 'string' },
            message: 'string',
            orderId: 'string',
            qualificationId: 'number',
            registerResult: 'number',
            remark: 'string',
            requestId: 'string',
            signCode: 'string',
            signName: 'string',
            signStatus: 'number',
            signTag: 'string',
            signUsage: 'string',
            thirdParty: 'boolean',
        };
    }
    validate() {
        if (this.auditInfo && typeof this.auditInfo.validate === 'function') {
            this.auditInfo.validate();
        }
        if (Array.isArray(this.fileUrlList)) {
            $dara.Model.validateArray(this.fileUrlList);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsSignResponseBody = GetSmsSignResponseBody;
class GetSmsSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSmsSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsSignResponse = GetSmsSignResponse;
class GetSmsTemplateRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsTemplateRequest = GetSmsTemplateRequest;
class GetSmsTemplateResponseBody extends $dara.Model {
    static names() {
        return {
            applyScene: 'ApplyScene',
            auditInfo: 'AuditInfo',
            code: 'Code',
            createDate: 'CreateDate',
            fileUrlList: 'FileUrlList',
            intlType: 'IntlType',
            message: 'Message',
            moreDataFileUrlList: 'MoreDataFileUrlList',
            orderId: 'OrderId',
            relatedSignName: 'RelatedSignName',
            remark: 'Remark',
            requestId: 'RequestId',
            templateCode: 'TemplateCode',
            templateContent: 'TemplateContent',
            templateName: 'TemplateName',
            templateStatus: 'TemplateStatus',
            templateTag: 'TemplateTag',
            templateType: 'TemplateType',
            variableAttribute: 'VariableAttribute',
            vendorAuditStatus: 'VendorAuditStatus',
        };
    }
    static types() {
        return {
            applyScene: 'string',
            auditInfo: GetSmsTemplateResponseBodyAuditInfo,
            code: 'string',
            createDate: 'string',
            fileUrlList: GetSmsTemplateResponseBodyFileUrlList,
            intlType: 'number',
            message: 'string',
            moreDataFileUrlList: GetSmsTemplateResponseBodyMoreDataFileUrlList,
            orderId: 'string',
            relatedSignName: 'string',
            remark: 'string',
            requestId: 'string',
            templateCode: 'string',
            templateContent: 'string',
            templateName: 'string',
            templateStatus: 'string',
            templateTag: 'number',
            templateType: 'string',
            variableAttribute: 'string',
            vendorAuditStatus: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    validate() {
        if (this.auditInfo && typeof this.auditInfo.validate === 'function') {
            this.auditInfo.validate();
        }
        if (this.fileUrlList && typeof this.fileUrlList.validate === 'function') {
            this.fileUrlList.validate();
        }
        if (this.moreDataFileUrlList && typeof this.moreDataFileUrlList.validate === 'function') {
            this.moreDataFileUrlList.validate();
        }
        if (this.vendorAuditStatus) {
            $dara.Model.validateMap(this.vendorAuditStatus);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsTemplateResponseBody = GetSmsTemplateResponseBody;
class GetSmsTemplateResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSmsTemplateResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsTemplateResponse = GetSmsTemplateResponse;
class ListTagResourcesRequest extends $dara.Model {
    static names() {
        return {
            nextToken: 'NextToken',
            ownerId: 'OwnerId',
            pageSize: 'PageSize',
            prodCode: 'ProdCode',
            regionId: 'RegionId',
            resourceId: 'ResourceId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            resourceType: 'ResourceType',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            ownerId: 'number',
            pageSize: 'number',
            prodCode: 'string',
            regionId: 'string',
            resourceId: { 'type': 'array', 'itemType': 'string' },
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            resourceType: 'string',
            tag: { 'type': 'array', 'itemType': ListTagResourcesRequestTag },
        };
    }
    validate() {
        if (Array.isArray(this.resourceId)) {
            $dara.Model.validateArray(this.resourceId);
        }
        if (Array.isArray(this.tag)) {
            $dara.Model.validateArray(this.tag);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTagResourcesRequest = ListTagResourcesRequest;
class ListTagResourcesResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            nextToken: 'NextToken',
            requestId: 'RequestId',
            tagResources: 'TagResources',
        };
    }
    static types() {
        return {
            code: 'string',
            nextToken: 'string',
            requestId: 'string',
            tagResources: ListTagResourcesResponseBodyTagResources,
        };
    }
    validate() {
        if (this.tagResources && typeof this.tagResources.validate === 'function') {
            this.tagResources.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTagResourcesResponseBody = ListTagResourcesResponseBody;
class ListTagResourcesResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListTagResourcesResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTagResourcesResponse = ListTagResourcesResponse;
class ModifySmsSignRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signFileList: 'SignFileList',
            signName: 'SignName',
            signSource: 'SignSource',
            signType: 'SignType',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signFileList: { 'type': 'array', 'itemType': ModifySmsSignRequestSignFileList },
            signName: 'string',
            signSource: 'number',
            signType: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.signFileList)) {
            $dara.Model.validateArray(this.signFileList);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ModifySmsSignRequest = ModifySmsSignRequest;
class ModifySmsSignResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ModifySmsSignResponseBody = ModifySmsSignResponseBody;
class ModifySmsSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifySmsSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ModifySmsSignResponse = ModifySmsSignResponse;
class ModifySmsTemplateRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateCode: 'TemplateCode',
            templateContent: 'TemplateContent',
            templateName: 'TemplateName',
            templateType: 'TemplateType',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateCode: 'string',
            templateContent: 'string',
            templateName: 'string',
            templateType: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ModifySmsTemplateRequest = ModifySmsTemplateRequest;
class ModifySmsTemplateResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ModifySmsTemplateResponseBody = ModifySmsTemplateResponseBody;
class ModifySmsTemplateResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifySmsTemplateResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ModifySmsTemplateResponse = ModifySmsTemplateResponse;
class QueryCardSmsTemplateRequest extends $dara.Model {
    static names() {
        return {
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCardSmsTemplateRequest = QueryCardSmsTemplateRequest;
class QueryCardSmsTemplateResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryCardSmsTemplateResponseBodyData,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCardSmsTemplateResponseBody = QueryCardSmsTemplateResponseBody;
class QueryCardSmsTemplateResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCardSmsTemplateResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCardSmsTemplateResponse = QueryCardSmsTemplateResponse;
class QueryCardSmsTemplateReportRequest extends $dara.Model {
    static names() {
        return {
            endDate: 'EndDate',
            startDate: 'StartDate',
            templateCodes: 'TemplateCodes',
        };
    }
    static types() {
        return {
            endDate: 'string',
            startDate: 'string',
            templateCodes: { 'type': 'array', 'itemType': 'string' },
        };
    }
    validate() {
        if (Array.isArray(this.templateCodes)) {
            $dara.Model.validateArray(this.templateCodes);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCardSmsTemplateReportRequest = QueryCardSmsTemplateReportRequest;
class QueryCardSmsTemplateReportResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryCardSmsTemplateReportResponseBodyData,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCardSmsTemplateReportResponseBody = QueryCardSmsTemplateReportResponseBody;
class QueryCardSmsTemplateReportResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCardSmsTemplateReportResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCardSmsTemplateReportResponse = QueryCardSmsTemplateReportResponse;
class QueryExtCodeSignRequest extends $dara.Model {
    static names() {
        return {
            extCode: 'ExtCode',
            ownerId: 'OwnerId',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            extCode: 'string',
            ownerId: 'number',
            pageNo: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryExtCodeSignRequest = QueryExtCodeSignRequest;
class QueryExtCodeSignResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: QueryExtCodeSignResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryExtCodeSignResponseBody = QueryExtCodeSignResponseBody;
class QueryExtCodeSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryExtCodeSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryExtCodeSignResponse = QueryExtCodeSignResponse;
class QueryMobilesCardSupportRequest extends $dara.Model {
    static names() {
        return {
            mobiles: 'Mobiles',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            mobiles: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
            templateCode: 'string',
        };
    }
    validate() {
        if (Array.isArray(this.mobiles)) {
            $dara.Model.validateArray(this.mobiles);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMobilesCardSupportRequest = QueryMobilesCardSupportRequest;
class QueryMobilesCardSupportShrinkRequest extends $dara.Model {
    static names() {
        return {
            mobilesShrink: 'Mobiles',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            mobilesShrink: 'string',
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMobilesCardSupportShrinkRequest = QueryMobilesCardSupportShrinkRequest;
class QueryMobilesCardSupportResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryMobilesCardSupportResponseBodyData,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMobilesCardSupportResponseBody = QueryMobilesCardSupportResponseBody;
class QueryMobilesCardSupportResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryMobilesCardSupportResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMobilesCardSupportResponse = QueryMobilesCardSupportResponse;
class QueryPageSmartShortUrlLogRequest extends $dara.Model {
    static names() {
        return {
            createDateEnd: 'CreateDateEnd',
            createDateStart: 'CreateDateStart',
            ownerId: 'OwnerId',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            phoneNumber: 'PhoneNumber',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            shortUrl: 'ShortUrl',
        };
    }
    static types() {
        return {
            createDateEnd: 'number',
            createDateStart: 'number',
            ownerId: 'number',
            pageNo: 'number',
            pageSize: 'number',
            phoneNumber: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            shortUrl: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPageSmartShortUrlLogRequest = QueryPageSmartShortUrlLogRequest;
class QueryPageSmartShortUrlLogResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            model: 'Model',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            model: QueryPageSmartShortUrlLogResponseBodyModel,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.model && typeof this.model.validate === 'function') {
            this.model.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPageSmartShortUrlLogResponseBody = QueryPageSmartShortUrlLogResponseBody;
class QueryPageSmartShortUrlLogResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryPageSmartShortUrlLogResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPageSmartShortUrlLogResponse = QueryPageSmartShortUrlLogResponse;
class QuerySendDetailsRequest extends $dara.Model {
    static names() {
        return {
            bizId: 'BizId',
            currentPage: 'CurrentPage',
            ownerId: 'OwnerId',
            pageSize: 'PageSize',
            phoneNumber: 'PhoneNumber',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sendDate: 'SendDate',
        };
    }
    static types() {
        return {
            bizId: 'string',
            currentPage: 'number',
            ownerId: 'number',
            pageSize: 'number',
            phoneNumber: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sendDate: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendDetailsRequest = QuerySendDetailsRequest;
class QuerySendDetailsResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            smsSendDetailDTOs: 'SmsSendDetailDTOs',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            smsSendDetailDTOs: QuerySendDetailsResponseBodySmsSendDetailDTOs,
            totalCount: 'string',
        };
    }
    validate() {
        if (this.smsSendDetailDTOs && typeof this.smsSendDetailDTOs.validate === 'function') {
            this.smsSendDetailDTOs.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendDetailsResponseBody = QuerySendDetailsResponseBody;
class QuerySendDetailsResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySendDetailsResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendDetailsResponse = QuerySendDetailsResponse;
class QuerySendStatisticsRequest extends $dara.Model {
    static names() {
        return {
            endDate: 'EndDate',
            isGlobe: 'IsGlobe',
            ownerId: 'OwnerId',
            pageIndex: 'PageIndex',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
            startDate: 'StartDate',
            templateType: 'TemplateType',
        };
    }
    static types() {
        return {
            endDate: 'string',
            isGlobe: 'number',
            ownerId: 'number',
            pageIndex: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
            startDate: 'string',
            templateType: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendStatisticsRequest = QuerySendStatisticsRequest;
class QuerySendStatisticsResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySendStatisticsResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendStatisticsResponseBody = QuerySendStatisticsResponseBody;
class QuerySendStatisticsResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySendStatisticsResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendStatisticsResponse = QuerySendStatisticsResponse;
class QueryShortUrlRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            shortUrl: 'ShortUrl',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            shortUrl: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryShortUrlRequest = QueryShortUrlRequest;
class QueryShortUrlResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryShortUrlResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryShortUrlResponseBody = QueryShortUrlResponseBody;
class QueryShortUrlResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryShortUrlResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryShortUrlResponse = QueryShortUrlResponse;
class QuerySingleSmsQualificationRequest extends $dara.Model {
    static names() {
        return {
            orderId: 'OrderId',
            ownerId: 'OwnerId',
            qualificationGroupId: 'QualificationGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            orderId: 'number',
            ownerId: 'number',
            qualificationGroupId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleSmsQualificationRequest = QuerySingleSmsQualificationRequest;
class QuerySingleSmsQualificationResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: QuerySingleSmsQualificationResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleSmsQualificationResponseBody = QuerySingleSmsQualificationResponseBody;
class QuerySingleSmsQualificationResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySingleSmsQualificationResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleSmsQualificationResponse = QuerySingleSmsQualificationResponse;
class QuerySmsAuthorizationLetterRequest extends $dara.Model {
    static names() {
        return {
            authorizationLetterIdList: 'AuthorizationLetterIdList',
            organizationCode: 'OrganizationCode',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
            state: 'State',
            status: 'Status',
        };
    }
    static types() {
        return {
            authorizationLetterIdList: { 'type': 'array', 'itemType': 'number' },
            organizationCode: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
            state: 'string',
            status: 'string',
        };
    }
    validate() {
        if (Array.isArray(this.authorizationLetterIdList)) {
            $dara.Model.validateArray(this.authorizationLetterIdList);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsAuthorizationLetterRequest = QuerySmsAuthorizationLetterRequest;
class QuerySmsAuthorizationLetterShrinkRequest extends $dara.Model {
    static names() {
        return {
            authorizationLetterIdListShrink: 'AuthorizationLetterIdList',
            organizationCode: 'OrganizationCode',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
            state: 'State',
            status: 'Status',
        };
    }
    static types() {
        return {
            authorizationLetterIdListShrink: 'string',
            organizationCode: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
            state: 'string',
            status: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsAuthorizationLetterShrinkRequest = QuerySmsAuthorizationLetterShrinkRequest;
class QuerySmsAuthorizationLetterResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: { 'type': 'array', 'itemType': QuerySmsAuthorizationLetterResponseBodyData },
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (Array.isArray(this.data)) {
            $dara.Model.validateArray(this.data);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsAuthorizationLetterResponseBody = QuerySmsAuthorizationLetterResponseBody;
class QuerySmsAuthorizationLetterResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySmsAuthorizationLetterResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsAuthorizationLetterResponse = QuerySmsAuthorizationLetterResponse;
class QuerySmsQualificationRecordRequest extends $dara.Model {
    static names() {
        return {
            companyName: 'CompanyName',
            legalPersonName: 'LegalPersonName',
            ownerId: 'OwnerId',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            qualificationGroupName: 'QualificationGroupName',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            state: 'State',
            useBySelf: 'UseBySelf',
            workOrderId: 'WorkOrderId',
        };
    }
    static types() {
        return {
            companyName: 'string',
            legalPersonName: 'string',
            ownerId: 'number',
            pageNo: 'number',
            pageSize: 'number',
            qualificationGroupName: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            state: 'string',
            useBySelf: 'boolean',
            workOrderId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsQualificationRecordRequest = QuerySmsQualificationRecordRequest;
class QuerySmsQualificationRecordResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: QuerySmsQualificationRecordResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsQualificationRecordResponseBody = QuerySmsQualificationRecordResponseBody;
class QuerySmsQualificationRecordResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySmsQualificationRecordResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsQualificationRecordResponse = QuerySmsQualificationRecordResponse;
class QuerySmsSignRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsSignRequest = QuerySmsSignRequest;
class QuerySmsSignResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            createDate: 'CreateDate',
            message: 'Message',
            reason: 'Reason',
            requestId: 'RequestId',
            signName: 'SignName',
            signStatus: 'SignStatus',
        };
    }
    static types() {
        return {
            code: 'string',
            createDate: 'string',
            message: 'string',
            reason: 'string',
            requestId: 'string',
            signName: 'string',
            signStatus: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsSignResponseBody = QuerySmsSignResponseBody;
class QuerySmsSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySmsSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsSignResponse = QuerySmsSignResponse;
class QuerySmsSignListRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            pageIndex: 'PageIndex',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            pageIndex: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsSignListRequest = QuerySmsSignListRequest;
class QuerySmsSignListResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            currentPage: 'CurrentPage',
            message: 'Message',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            smsSignList: 'SmsSignList',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            code: 'string',
            currentPage: 'number',
            message: 'string',
            pageSize: 'number',
            requestId: 'string',
            smsSignList: { 'type': 'array', 'itemType': QuerySmsSignListResponseBodySmsSignList },
            totalCount: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.smsSignList)) {
            $dara.Model.validateArray(this.smsSignList);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsSignListResponseBody = QuerySmsSignListResponseBody;
class QuerySmsSignListResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySmsSignListResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsSignListResponse = QuerySmsSignListResponse;
class QuerySmsTemplateRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateCode: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsTemplateRequest = QuerySmsTemplateRequest;
class QuerySmsTemplateResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            createDate: 'CreateDate',
            message: 'Message',
            reason: 'Reason',
            requestId: 'RequestId',
            templateCode: 'TemplateCode',
            templateContent: 'TemplateContent',
            templateName: 'TemplateName',
            templateStatus: 'TemplateStatus',
            templateType: 'TemplateType',
        };
    }
    static types() {
        return {
            code: 'string',
            createDate: 'string',
            message: 'string',
            reason: 'string',
            requestId: 'string',
            templateCode: 'string',
            templateContent: 'string',
            templateName: 'string',
            templateStatus: 'number',
            templateType: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsTemplateResponseBody = QuerySmsTemplateResponseBody;
class QuerySmsTemplateResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySmsTemplateResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsTemplateResponse = QuerySmsTemplateResponse;
class QuerySmsTemplateListRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            pageIndex: 'PageIndex',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            pageIndex: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsTemplateListRequest = QuerySmsTemplateListRequest;
class QuerySmsTemplateListResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            currentPage: 'CurrentPage',
            message: 'Message',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            smsTemplateList: 'SmsTemplateList',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            code: 'string',
            currentPage: 'number',
            message: 'string',
            pageSize: 'number',
            requestId: 'string',
            smsTemplateList: { 'type': 'array', 'itemType': QuerySmsTemplateListResponseBodySmsTemplateList },
            totalCount: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.smsTemplateList)) {
            $dara.Model.validateArray(this.smsTemplateList);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsTemplateListResponseBody = QuerySmsTemplateListResponseBody;
class QuerySmsTemplateListResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySmsTemplateListResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySmsTemplateListResponse = QuerySmsTemplateListResponse;
class RequiredPhoneCodeRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            phoneNo: 'PhoneNo',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            phoneNo: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.RequiredPhoneCodeRequest = RequiredPhoneCodeRequest;
class RequiredPhoneCodeResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.RequiredPhoneCodeResponseBody = RequiredPhoneCodeResponseBody;
class RequiredPhoneCodeResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RequiredPhoneCodeResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.RequiredPhoneCodeResponse = RequiredPhoneCodeResponse;
class SendBatchCardSmsRequest extends $dara.Model {
    static names() {
        return {
            cardTemplateCode: 'CardTemplateCode',
            cardTemplateParamJson: 'CardTemplateParamJson',
            digitalTemplateCode: 'DigitalTemplateCode',
            digitalTemplateParamJson: 'DigitalTemplateParamJson',
            fallbackType: 'FallbackType',
            outId: 'OutId',
            phoneNumberJson: 'PhoneNumberJson',
            signNameJson: 'SignNameJson',
            smsTemplateCode: 'SmsTemplateCode',
            smsTemplateParamJson: 'SmsTemplateParamJson',
            smsUpExtendCodeJson: 'SmsUpExtendCodeJson',
            templateCode: 'TemplateCode',
            templateParamJson: 'TemplateParamJson',
        };
    }
    static types() {
        return {
            cardTemplateCode: 'string',
            cardTemplateParamJson: 'string',
            digitalTemplateCode: 'string',
            digitalTemplateParamJson: 'string',
            fallbackType: 'string',
            outId: 'string',
            phoneNumberJson: 'string',
            signNameJson: 'string',
            smsTemplateCode: 'string',
            smsTemplateParamJson: 'string',
            smsUpExtendCodeJson: 'string',
            templateCode: 'string',
            templateParamJson: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendBatchCardSmsRequest = SendBatchCardSmsRequest;
class SendBatchCardSmsResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: SendBatchCardSmsResponseBodyData,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendBatchCardSmsResponseBody = SendBatchCardSmsResponseBody;
class SendBatchCardSmsResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendBatchCardSmsResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendBatchCardSmsResponse = SendBatchCardSmsResponse;
class SendBatchSmsRequest extends $dara.Model {
    static names() {
        return {
            outId: 'OutId',
            ownerId: 'OwnerId',
            phoneNumberJson: 'PhoneNumberJson',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signNameJson: 'SignNameJson',
            smsUpExtendCodeJson: 'SmsUpExtendCodeJson',
            templateCode: 'TemplateCode',
            templateParamJson: 'TemplateParamJson',
        };
    }
    static types() {
        return {
            outId: 'string',
            ownerId: 'number',
            phoneNumberJson: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signNameJson: 'string',
            smsUpExtendCodeJson: 'string',
            templateCode: 'string',
            templateParamJson: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendBatchSmsRequest = SendBatchSmsRequest;
class SendBatchSmsResponseBody extends $dara.Model {
    static names() {
        return {
            bizId: 'BizId',
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            bizId: 'string',
            code: 'string',
            message: 'string',
            requestId: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendBatchSmsResponseBody = SendBatchSmsResponseBody;
class SendBatchSmsResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendBatchSmsResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendBatchSmsResponse = SendBatchSmsResponse;
class SendCardSmsRequest extends $dara.Model {
    static names() {
        return {
            cardObjects: 'CardObjects',
            cardTemplateCode: 'CardTemplateCode',
            digitalTemplateCode: 'DigitalTemplateCode',
            digitalTemplateParam: 'DigitalTemplateParam',
            fallbackType: 'FallbackType',
            outId: 'OutId',
            signName: 'SignName',
            smsTemplateCode: 'SmsTemplateCode',
            smsTemplateParam: 'SmsTemplateParam',
            smsUpExtendCode: 'SmsUpExtendCode',
            templateCode: 'TemplateCode',
            templateParam: 'TemplateParam',
        };
    }
    static types() {
        return {
            cardObjects: { 'type': 'array', 'itemType': SendCardSmsRequestCardObjects },
            cardTemplateCode: 'string',
            digitalTemplateCode: 'string',
            digitalTemplateParam: 'string',
            fallbackType: 'string',
            outId: 'string',
            signName: 'string',
            smsTemplateCode: 'string',
            smsTemplateParam: 'string',
            smsUpExtendCode: 'string',
            templateCode: 'string',
            templateParam: 'string',
        };
    }
    validate() {
        if (Array.isArray(this.cardObjects)) {
            $dara.Model.validateArray(this.cardObjects);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendCardSmsRequest = SendCardSmsRequest;
class SendCardSmsResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: SendCardSmsResponseBodyData,
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        if (this.data && typeof this.data.validate === 'function') {
            this.data.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendCardSmsResponseBody = SendCardSmsResponseBody;
class SendCardSmsResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendCardSmsResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendCardSmsResponse = SendCardSmsResponse;
class SendSmsRequest extends $dara.Model {
    static names() {
        return {
            outId: 'OutId',
            ownerId: 'OwnerId',
            phoneNumbers: 'PhoneNumbers',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
            smsUpExtendCode: 'SmsUpExtendCode',
            templateCode: 'TemplateCode',
            templateParam: 'TemplateParam',
        };
    }
    static types() {
        return {
            outId: 'string',
            ownerId: 'number',
            phoneNumbers: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
            smsUpExtendCode: 'string',
            templateCode: 'string',
            templateParam: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendSmsRequest = SendSmsRequest;
class SendSmsResponseBody extends $dara.Model {
    static names() {
        return {
            bizId: 'BizId',
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            bizId: 'string',
            code: 'string',
            message: 'string',
            requestId: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendSmsResponseBody = SendSmsResponseBody;
class SendSmsResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendSmsResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SendSmsResponse = SendSmsResponse;
class SmsConversionIntlRequest extends $dara.Model {
    static names() {
        return {
            conversionTime: 'ConversionTime',
            delivered: 'Delivered',
            messageId: 'MessageId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            conversionTime: 'number',
            delivered: 'boolean',
            messageId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SmsConversionIntlRequest = SmsConversionIntlRequest;
class SmsConversionIntlResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SmsConversionIntlResponseBody = SmsConversionIntlResponseBody;
class SmsConversionIntlResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SmsConversionIntlResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SmsConversionIntlResponse = SmsConversionIntlResponse;
class SubmitSmsQualificationRequest extends $dara.Model {
    static names() {
        return {
            adminIDCardExpDate: 'AdminIDCardExpDate',
            adminIDCardFrontFace: 'AdminIDCardFrontFace',
            adminIDCardNo: 'AdminIDCardNo',
            adminIDCardPic: 'AdminIDCardPic',
            adminIDCardType: 'AdminIDCardType',
            adminName: 'AdminName',
            adminPhoneNo: 'AdminPhoneNo',
            businessLicensePics: 'BusinessLicensePics',
            bussinessLicenseExpDate: 'BussinessLicenseExpDate',
            certifyCode: 'CertifyCode',
            companyName: 'CompanyName',
            companyType: 'CompanyType',
            legalPersonIDCardNo: 'LegalPersonIDCardNo',
            legalPersonIDCardType: 'LegalPersonIDCardType',
            legalPersonIdCardBackSide: 'LegalPersonIdCardBackSide',
            legalPersonIdCardEffTime: 'LegalPersonIdCardEffTime',
            legalPersonIdCardFrontSide: 'LegalPersonIdCardFrontSide',
            legalPersonName: 'LegalPersonName',
            organizationCode: 'OrganizationCode',
            otherFiles: 'OtherFiles',
            ownerId: 'OwnerId',
            qualificationName: 'QualificationName',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            useBySelf: 'UseBySelf',
            whetherShare: 'WhetherShare',
        };
    }
    static types() {
        return {
            adminIDCardExpDate: 'string',
            adminIDCardFrontFace: 'string',
            adminIDCardNo: 'string',
            adminIDCardPic: 'string',
            adminIDCardType: 'string',
            adminName: 'string',
            adminPhoneNo: 'string',
            businessLicensePics: { 'type': 'array', 'itemType': SubmitSmsQualificationRequestBusinessLicensePics },
            bussinessLicenseExpDate: 'string',
            certifyCode: 'string',
            companyName: 'string',
            companyType: 'string',
            legalPersonIDCardNo: 'string',
            legalPersonIDCardType: 'string',
            legalPersonIdCardBackSide: 'string',
            legalPersonIdCardEffTime: 'string',
            legalPersonIdCardFrontSide: 'string',
            legalPersonName: 'string',
            organizationCode: 'string',
            otherFiles: { 'type': 'array', 'itemType': SubmitSmsQualificationRequestOtherFiles },
            ownerId: 'number',
            qualificationName: 'string',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            useBySelf: 'boolean',
            whetherShare: 'boolean',
        };
    }
    validate() {
        if (Array.isArray(this.businessLicensePics)) {
            $dara.Model.validateArray(this.businessLicensePics);
        }
        if (Array.isArray(this.otherFiles)) {
            $dara.Model.validateArray(this.otherFiles);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitSmsQualificationRequest = SubmitSmsQualificationRequest;
class SubmitSmsQualificationShrinkRequest extends $dara.Model {
    static names() {
        return {
            adminIDCardExpDate: 'AdminIDCardExpDate',
            adminIDCardFrontFace: 'AdminIDCardFrontFace',
            adminIDCardNo: 'AdminIDCardNo',
            adminIDCardPic: 'AdminIDCardPic',
            adminIDCardType: 'AdminIDCardType',
            adminName: 'AdminName',
            adminPhoneNo: 'AdminPhoneNo',
            businessLicensePicsShrink: 'BusinessLicensePics',
            bussinessLicenseExpDate: 'BussinessLicenseExpDate',
            certifyCode: 'CertifyCode',
            companyName: 'CompanyName',
            companyType: 'CompanyType',
            legalPersonIDCardNo: 'LegalPersonIDCardNo',
            legalPersonIDCardType: 'LegalPersonIDCardType',
            legalPersonIdCardBackSide: 'LegalPersonIdCardBackSide',
            legalPersonIdCardEffTime: 'LegalPersonIdCardEffTime',
            legalPersonIdCardFrontSide: 'LegalPersonIdCardFrontSide',
            legalPersonName: 'LegalPersonName',
            organizationCode: 'OrganizationCode',
            otherFilesShrink: 'OtherFiles',
            ownerId: 'OwnerId',
            qualificationName: 'QualificationName',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            useBySelf: 'UseBySelf',
            whetherShare: 'WhetherShare',
        };
    }
    static types() {
        return {
            adminIDCardExpDate: 'string',
            adminIDCardFrontFace: 'string',
            adminIDCardNo: 'string',
            adminIDCardPic: 'string',
            adminIDCardType: 'string',
            adminName: 'string',
            adminPhoneNo: 'string',
            businessLicensePicsShrink: 'string',
            bussinessLicenseExpDate: 'string',
            certifyCode: 'string',
            companyName: 'string',
            companyType: 'string',
            legalPersonIDCardNo: 'string',
            legalPersonIDCardType: 'string',
            legalPersonIdCardBackSide: 'string',
            legalPersonIdCardEffTime: 'string',
            legalPersonIdCardFrontSide: 'string',
            legalPersonName: 'string',
            organizationCode: 'string',
            otherFilesShrink: 'string',
            ownerId: 'number',
            qualificationName: 'string',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            useBySelf: 'boolean',
            whetherShare: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitSmsQualificationShrinkRequest = SubmitSmsQualificationShrinkRequest;
class SubmitSmsQualificationResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitSmsQualificationResponseBody = SubmitSmsQualificationResponseBody;
class SubmitSmsQualificationResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SubmitSmsQualificationResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitSmsQualificationResponse = SubmitSmsQualificationResponse;
class TagResourcesRequest extends $dara.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            prodCode: 'ProdCode',
            regionId: 'RegionId',
            resourceId: 'ResourceId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            resourceType: 'ResourceType',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            prodCode: 'string',
            regionId: 'string',
            resourceId: { 'type': 'array', 'itemType': 'string' },
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            resourceType: 'string',
            tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },
        };
    }
    validate() {
        if (Array.isArray(this.resourceId)) {
            $dara.Model.validateArray(this.resourceId);
        }
        if (Array.isArray(this.tag)) {
            $dara.Model.validateArray(this.tag);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.TagResourcesRequest = TagResourcesRequest;
class TagResourcesResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            requestId: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.TagResourcesResponseBody = TagResourcesResponseBody;
class TagResourcesResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TagResourcesResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.TagResourcesResponse = TagResourcesResponse;
class UntagResourcesRequest extends $dara.Model {
    static names() {
        return {
            all: 'All',
            ownerId: 'OwnerId',
            prodCode: 'ProdCode',
            regionId: 'RegionId',
            resourceId: 'ResourceId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            resourceType: 'ResourceType',
            tagKey: 'TagKey',
        };
    }
    static types() {
        return {
            all: 'boolean',
            ownerId: 'number',
            prodCode: 'string',
            regionId: 'string',
            resourceId: { 'type': 'array', 'itemType': 'string' },
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            resourceType: 'string',
            tagKey: { 'type': 'array', 'itemType': 'string' },
        };
    }
    validate() {
        if (Array.isArray(this.resourceId)) {
            $dara.Model.validateArray(this.resourceId);
        }
        if (Array.isArray(this.tagKey)) {
            $dara.Model.validateArray(this.tagKey);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UntagResourcesRequest = UntagResourcesRequest;
class UntagResourcesResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            requestId: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UntagResourcesResponseBody = UntagResourcesResponseBody;
class UntagResourcesResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UntagResourcesResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UntagResourcesResponse = UntagResourcesResponse;
class UpdateExtCodeSignRequest extends $dara.Model {
    static names() {
        return {
            existExtCode: 'ExistExtCode',
            newExtCode: 'NewExtCode',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            existExtCode: 'string',
            newExtCode: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateExtCodeSignRequest = UpdateExtCodeSignRequest;
class UpdateExtCodeSignResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateExtCodeSignResponseBody = UpdateExtCodeSignResponseBody;
class UpdateExtCodeSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateExtCodeSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateExtCodeSignResponse = UpdateExtCodeSignResponse;
class UpdateSmsQualificationRequest extends $dara.Model {
    static names() {
        return {
            adminIDCardExpDate: 'AdminIDCardExpDate',
            adminIDCardFrontFace: 'AdminIDCardFrontFace',
            adminIDCardNo: 'AdminIDCardNo',
            adminIDCardPic: 'AdminIDCardPic',
            adminIDCardType: 'AdminIDCardType',
            adminName: 'AdminName',
            adminPhoneNo: 'AdminPhoneNo',
            businessLicensePics: 'BusinessLicensePics',
            bussinessLicenseExpDate: 'BussinessLicenseExpDate',
            certifyCode: 'CertifyCode',
            companyName: 'CompanyName',
            legalPersonIDCardNo: 'LegalPersonIDCardNo',
            legalPersonIDCardType: 'LegalPersonIDCardType',
            legalPersonIdCardBackSide: 'LegalPersonIdCardBackSide',
            legalPersonIdCardEffTime: 'LegalPersonIdCardEffTime',
            legalPersonIdCardFrontSide: 'LegalPersonIdCardFrontSide',
            legalPersonName: 'LegalPersonName',
            orderId: 'OrderId',
            otherFiles: 'OtherFiles',
            ownerId: 'OwnerId',
            qualificationGroupId: 'QualificationGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            adminIDCardExpDate: 'string',
            adminIDCardFrontFace: 'string',
            adminIDCardNo: 'string',
            adminIDCardPic: 'string',
            adminIDCardType: 'string',
            adminName: 'string',
            adminPhoneNo: 'string',
            businessLicensePics: { 'type': 'array', 'itemType': UpdateSmsQualificationRequestBusinessLicensePics },
            bussinessLicenseExpDate: 'string',
            certifyCode: 'string',
            companyName: 'string',
            legalPersonIDCardNo: 'string',
            legalPersonIDCardType: 'string',
            legalPersonIdCardBackSide: 'string',
            legalPersonIdCardEffTime: 'string',
            legalPersonIdCardFrontSide: 'string',
            legalPersonName: 'string',
            orderId: 'number',
            otherFiles: { 'type': 'array', 'itemType': UpdateSmsQualificationRequestOtherFiles },
            ownerId: 'number',
            qualificationGroupId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.businessLicensePics)) {
            $dara.Model.validateArray(this.businessLicensePics);
        }
        if (Array.isArray(this.otherFiles)) {
            $dara.Model.validateArray(this.otherFiles);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsQualificationRequest = UpdateSmsQualificationRequest;
class UpdateSmsQualificationShrinkRequest extends $dara.Model {
    static names() {
        return {
            adminIDCardExpDate: 'AdminIDCardExpDate',
            adminIDCardFrontFace: 'AdminIDCardFrontFace',
            adminIDCardNo: 'AdminIDCardNo',
            adminIDCardPic: 'AdminIDCardPic',
            adminIDCardType: 'AdminIDCardType',
            adminName: 'AdminName',
            adminPhoneNo: 'AdminPhoneNo',
            businessLicensePicsShrink: 'BusinessLicensePics',
            bussinessLicenseExpDate: 'BussinessLicenseExpDate',
            certifyCode: 'CertifyCode',
            companyName: 'CompanyName',
            legalPersonIDCardNo: 'LegalPersonIDCardNo',
            legalPersonIDCardType: 'LegalPersonIDCardType',
            legalPersonIdCardBackSide: 'LegalPersonIdCardBackSide',
            legalPersonIdCardEffTime: 'LegalPersonIdCardEffTime',
            legalPersonIdCardFrontSide: 'LegalPersonIdCardFrontSide',
            legalPersonName: 'LegalPersonName',
            orderId: 'OrderId',
            otherFilesShrink: 'OtherFiles',
            ownerId: 'OwnerId',
            qualificationGroupId: 'QualificationGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            adminIDCardExpDate: 'string',
            adminIDCardFrontFace: 'string',
            adminIDCardNo: 'string',
            adminIDCardPic: 'string',
            adminIDCardType: 'string',
            adminName: 'string',
            adminPhoneNo: 'string',
            businessLicensePicsShrink: 'string',
            bussinessLicenseExpDate: 'string',
            certifyCode: 'string',
            companyName: 'string',
            legalPersonIDCardNo: 'string',
            legalPersonIDCardType: 'string',
            legalPersonIdCardBackSide: 'string',
            legalPersonIdCardEffTime: 'string',
            legalPersonIdCardFrontSide: 'string',
            legalPersonName: 'string',
            orderId: 'number',
            otherFilesShrink: 'string',
            ownerId: 'number',
            qualificationGroupId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsQualificationShrinkRequest = UpdateSmsQualificationShrinkRequest;
class UpdateSmsQualificationResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsQualificationResponseBody = UpdateSmsQualificationResponseBody;
class UpdateSmsQualificationResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSmsQualificationResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsQualificationResponse = UpdateSmsQualificationResponse;
class UpdateSmsSignRequest extends $dara.Model {
    static names() {
        return {
            applySceneContent: 'ApplySceneContent',
            authorizationLetterId: 'AuthorizationLetterId',
            moreData: 'MoreData',
            ownerId: 'OwnerId',
            qualificationId: 'QualificationId',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
            signSource: 'SignSource',
            signType: 'SignType',
            thirdParty: 'ThirdParty',
        };
    }
    static types() {
        return {
            applySceneContent: 'string',
            authorizationLetterId: 'number',
            moreData: { 'type': 'array', 'itemType': 'string' },
            ownerId: 'number',
            qualificationId: 'number',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
            signSource: 'number',
            signType: 'number',
            thirdParty: 'boolean',
        };
    }
    validate() {
        if (Array.isArray(this.moreData)) {
            $dara.Model.validateArray(this.moreData);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsSignRequest = UpdateSmsSignRequest;
class UpdateSmsSignShrinkRequest extends $dara.Model {
    static names() {
        return {
            applySceneContent: 'ApplySceneContent',
            authorizationLetterId: 'AuthorizationLetterId',
            moreDataShrink: 'MoreData',
            ownerId: 'OwnerId',
            qualificationId: 'QualificationId',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            signName: 'SignName',
            signSource: 'SignSource',
            signType: 'SignType',
            thirdParty: 'ThirdParty',
        };
    }
    static types() {
        return {
            applySceneContent: 'string',
            authorizationLetterId: 'number',
            moreDataShrink: 'string',
            ownerId: 'number',
            qualificationId: 'number',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            signName: 'string',
            signSource: 'number',
            signType: 'number',
            thirdParty: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsSignShrinkRequest = UpdateSmsSignShrinkRequest;
class UpdateSmsSignResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            orderId: 'OrderId',
            requestId: 'RequestId',
            signName: 'SignName',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            orderId: 'string',
            requestId: 'string',
            signName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsSignResponseBody = UpdateSmsSignResponseBody;
class UpdateSmsSignResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSmsSignResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsSignResponse = UpdateSmsSignResponse;
class UpdateSmsTemplateRequest extends $dara.Model {
    static names() {
        return {
            applySceneContent: 'ApplySceneContent',
            intlType: 'IntlType',
            moreData: 'MoreData',
            ownerId: 'OwnerId',
            relatedSignName: 'RelatedSignName',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateCode: 'TemplateCode',
            templateContent: 'TemplateContent',
            templateName: 'TemplateName',
            templateRule: 'TemplateRule',
            templateType: 'TemplateType',
        };
    }
    static types() {
        return {
            applySceneContent: 'string',
            intlType: 'number',
            moreData: { 'type': 'array', 'itemType': 'string' },
            ownerId: 'number',
            relatedSignName: 'string',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateCode: 'string',
            templateContent: 'string',
            templateName: 'string',
            templateRule: 'string',
            templateType: 'number',
        };
    }
    validate() {
        if (Array.isArray(this.moreData)) {
            $dara.Model.validateArray(this.moreData);
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsTemplateRequest = UpdateSmsTemplateRequest;
class UpdateSmsTemplateShrinkRequest extends $dara.Model {
    static names() {
        return {
            applySceneContent: 'ApplySceneContent',
            intlType: 'IntlType',
            moreDataShrink: 'MoreData',
            ownerId: 'OwnerId',
            relatedSignName: 'RelatedSignName',
            remark: 'Remark',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateCode: 'TemplateCode',
            templateContent: 'TemplateContent',
            templateName: 'TemplateName',
            templateRule: 'TemplateRule',
            templateType: 'TemplateType',
        };
    }
    static types() {
        return {
            applySceneContent: 'string',
            intlType: 'number',
            moreDataShrink: 'string',
            ownerId: 'number',
            relatedSignName: 'string',
            remark: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateCode: 'string',
            templateContent: 'string',
            templateName: 'string',
            templateRule: 'string',
            templateType: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsTemplateShrinkRequest = UpdateSmsTemplateShrinkRequest;
class UpdateSmsTemplateResponseBody extends $dara.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            orderId: 'OrderId',
            requestId: 'RequestId',
            templateCode: 'TemplateCode',
            templateName: 'TemplateName',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            orderId: 'string',
            requestId: 'string',
            templateCode: 'string',
            templateName: 'string',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsTemplateResponseBody = UpdateSmsTemplateResponseBody;
class UpdateSmsTemplateResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSmsTemplateResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSmsTemplateResponse = UpdateSmsTemplateResponse;
class ValidPhoneCodeRequest extends $dara.Model {
    static names() {
        return {
            certifyCode: 'CertifyCode',
            ownerId: 'OwnerId',
            phoneNo: 'PhoneNo',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            certifyCode: 'string',
            ownerId: 'number',
            phoneNo: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ValidPhoneCodeRequest = ValidPhoneCodeRequest;
class ValidPhoneCodeResponseBody extends $dara.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    validate() {
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ValidPhoneCodeResponseBody = ValidPhoneCodeResponseBody;
class ValidPhoneCodeResponse extends $dara.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ValidPhoneCodeResponseBody,
        };
    }
    validate() {
        if (this.headers) {
            $dara.Model.validateMap(this.headers);
        }
        if (this.body && typeof this.body.validate === 'function') {
            this.body.validate();
        }
        super.validate();
    }
    constructor(map) {
        super(map);
    }
}
exports.ValidPhoneCodeResponse = ValidPhoneCodeResponse;
class Client extends openapi_core_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "central";
        this._endpointMap = {
            'ap-southeast-1': "dysmsapi.ap-southeast-1.aliyuncs.com",
            'ap-southeast-5': "dysmsapi.ap-southeast-5.aliyuncs.com",
            'cn-beijing': "dysmsapi-proxy.cn-beijing.aliyuncs.com",
            'cn-hongkong': "dysmsapi-xman.cn-hongkong.aliyuncs.com",
            'eu-central-1': "dysmsapi.eu-central-1.aliyuncs.com",
            'us-east-1': "dysmsapi.us-east-1.aliyuncs.com",
        };
        this.checkConfig(config);
        this._endpoint = this.getEndpoint("dysmsapi", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!$dara.isNull(endpoint)) {
            return endpoint;
        }
        if (!$dara.isNull(endpointMap) && !$dara.isNull(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return openapi_core_2.OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    /**
     * 
     *
     * @param request - AddExtCodeSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddExtCodeSignResponse
     */
    async addExtCodeSignWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.extCode)) {
            query["ExtCode"] = request.extCode;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "AddExtCodeSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new AddExtCodeSignResponse({}));
    }
    /**
     * 
     *
     * @param request - AddExtCodeSignRequest
     * @returns AddExtCodeSignResponse
     */
    async addExtCodeSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.addExtCodeSignWithOptions(request, runtime);
    }
    /**
     * Creates a short URL.
     *
     * @remarks
     *   Before you call this operation, you must register the primary domain name of the source URL in the Short Message Service (SMS) console. After the domain name is registered, you can call this operation to create a short URL. For more information, see [Domain name registration](https://help.aliyun.com/document_detail/302325.html#title-mau-zdh-hd0).
     * *   You can create up to 3,000 short URLs within a natural day.
     * *   After a short URL is generated, a security review is required. Generally, the review takes 10 minutes to 2 hours to complete. Before the security review is passed, the short URL cannot be directly accessed.
     *
     * @param request - AddShortUrlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddShortUrlResponse
     */
    async addShortUrlWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let body = {};
        if (!$dara.isNull(request.effectiveDays)) {
            body["EffectiveDays"] = request.effectiveDays;
        }
        if (!$dara.isNull(request.shortUrlName)) {
            body["ShortUrlName"] = request.shortUrlName;
        }
        if (!$dara.isNull(request.sourceUrl)) {
            body["SourceUrl"] = request.sourceUrl;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
            body: openapi_core_2.OpenApiUtil.parseToMap(body),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "AddShortUrl",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new AddShortUrlResponse({}));
    }
    /**
     * Creates a short URL.
     *
     * @remarks
     *   Before you call this operation, you must register the primary domain name of the source URL in the Short Message Service (SMS) console. After the domain name is registered, you can call this operation to create a short URL. For more information, see [Domain name registration](https://help.aliyun.com/document_detail/302325.html#title-mau-zdh-hd0).
     * *   You can create up to 3,000 short URLs within a natural day.
     * *   After a short URL is generated, a security review is required. Generally, the review takes 10 minutes to 2 hours to complete. Before the security review is passed, the short URL cannot be directly accessed.
     *
     * @param request - AddShortUrlRequest
     * @returns AddShortUrlResponse
     */
    async addShortUrl(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.addShortUrlWithOptions(request, runtime);
    }
    /**
     * Creates a signature.
     *
     * @remarks
     * You can call the AddSmsSign operation or use the [Short Message Service (SMS) console](https://dysms.console.aliyun.com/dysms.htm#/overview) to create an SMS signature. The signature must comply with the [SMS signature specifications](https://help.aliyun.com/document_detail/108076.html). You can call the QuerySmsSign operation or use the SMS console to query the review status of the signature.
     * For more information, see [Usage notes](https://help.aliyun.com/document_detail/55324.html).
     * ### QPS limit
     * You can call this operation only once per second. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     * >
     * *   You cannot cancel the review of a signature.
     * *   Individual users can create only one verification code signature, and can create only one general-purpose signature within a natural day. If you need to apply for multiple signatures, we recommend that you upgrade your account to an enterprise user.
     * *   If you need to use the same signature for messages sent to recipients both in and outside the Chinese mainland, the signature must be a general-purpose signature.
     * *   If you apply for a signature or message template, you must specify the signature scenario or template type. You must also provide the information of your services, such as a website URL, a domain name with an ICP filing, an application download URL, or the name of your WeChat official account or mini program. For sign-in scenarios, you must also provide an account and password for tests. A detailed description can improve the review efficiency of signatures and templates.
     * *   An SMS signature must undergo a thorough review process before it can be approved for use.
     *
     * @param request - AddSmsSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddSmsSignResponse
     */
    async addSmsSignWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.remark)) {
            query["Remark"] = request.remark;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        if (!$dara.isNull(request.signSource)) {
            query["SignSource"] = request.signSource;
        }
        if (!$dara.isNull(request.signType)) {
            query["SignType"] = request.signType;
        }
        let body = {};
        if (!$dara.isNull(request.signFileList)) {
            body["SignFileList"] = request.signFileList;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
            body: openapi_core_2.OpenApiUtil.parseToMap(body),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "AddSmsSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new AddSmsSignResponse({}));
    }
    /**
     * Creates a signature.
     *
     * @remarks
     * You can call the AddSmsSign operation or use the [Short Message Service (SMS) console](https://dysms.console.aliyun.com/dysms.htm#/overview) to create an SMS signature. The signature must comply with the [SMS signature specifications](https://help.aliyun.com/document_detail/108076.html). You can call the QuerySmsSign operation or use the SMS console to query the review status of the signature.
     * For more information, see [Usage notes](https://help.aliyun.com/document_detail/55324.html).
     * ### QPS limit
     * You can call this operation only once per second. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     * >
     * *   You cannot cancel the review of a signature.
     * *   Individual users can create only one verification code signature, and can create only one general-purpose signature within a natural day. If you need to apply for multiple signatures, we recommend that you upgrade your account to an enterprise user.
     * *   If you need to use the same signature for messages sent to recipients both in and outside the Chinese mainland, the signature must be a general-purpose signature.
     * *   If you apply for a signature or message template, you must specify the signature scenario or template type. You must also provide the information of your services, such as a website URL, a domain name with an ICP filing, an application download URL, or the name of your WeChat official account or mini program. For sign-in scenarios, you must also provide an account and password for tests. A detailed description can improve the review efficiency of signatures and templates.
     * *   An SMS signature must undergo a thorough review process before it can be approved for use.
     *
     * @param request - AddSmsSignRequest
     * @returns AddSmsSignResponse
     */
    async addSmsSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.addSmsSignWithOptions(request, runtime);
    }
    /**
     * Creates a message template.
     *
     * @remarks
     * You can call the operation or use the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview) to apply for a message template. The template must comply with the [message template specifications](https://help.aliyun.com/document_detail/108253.html). You can call the [QuerySmsTemplate](https://help.aliyun.com/document_detail/419289.html) operation or use the Alibaba Cloud SMS console to check whether the message template is approved.
     * >
     * *   Message templates pending approval can be withdrawn. You can withdraw a message template pending approval on the Message Templates tab in the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview).
     * *   Message templates that have been approved can be deleted, and cannot be modified. You can delete a message template pending approval on the Message Templates tab in the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview).
     * *   If you call the AddSmsTemplate operation, you can apply for a maximum of 100 message templates in a calendar day. After you apply for a message template, we recommend that you wait for at least 30 seconds before you apply for another one. If you use the Alibaba Cloud SMS console, you can apply for an unlimited number of message templates.
     * *   Messages sent to the Chinese mainland and messages sent to countries or regions outside the Chinese mainland use separate message templates. Create message templates based on your needs.
     * *   If you apply for a signature or message template, you must specify the signature scenario or template type. You must also provide the information of your services, such as a website URL, a domain name with an ICP filing, an application download URL, or the name of your WeChat official account or mini program. For sign-in scenarios, you must also provide an account and password for tests. A detailed description can improve the review efficiency of signatures and templates.
     * *   A signature must undergo a thorough review process before it can be approved for use. For more information, see [Usage notes](https://help.aliyun.com/document_detail/55324.html).
     * ### QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @deprecated OpenAPI AddSmsTemplate is deprecated, please use Dysmsapi::2017-05-25::CreateSmsTemplate instead.
     *
     * @param request - AddSmsTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddSmsTemplateResponse
     */
    // Deprecated
    async addSmsTemplateWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.remark)) {
            query["Remark"] = request.remark;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.templateContent)) {
            query["TemplateContent"] = request.templateContent;
        }
        if (!$dara.isNull(request.templateName)) {
            query["TemplateName"] = request.templateName;
        }
        if (!$dara.isNull(request.templateType)) {
            query["TemplateType"] = request.templateType;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "AddSmsTemplate",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new AddSmsTemplateResponse({}));
    }
    /**
     * Creates a message template.
     *
     * @remarks
     * You can call the operation or use the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview) to apply for a message template. The template must comply with the [message template specifications](https://help.aliyun.com/document_detail/108253.html). You can call the [QuerySmsTemplate](https://help.aliyun.com/document_detail/419289.html) operation or use the Alibaba Cloud SMS console to check whether the message template is approved.
     * >
     * *   Message templates pending approval can be withdrawn. You can withdraw a message template pending approval on the Message Templates tab in the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview).
     * *   Message templates that have been approved can be deleted, and cannot be modified. You can delete a message template pending approval on the Message Templates tab in the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview).
     * *   If you call the AddSmsTemplate operation, you can apply for a maximum of 100 message templates in a calendar day. After you apply for a message template, we recommend that you wait for at least 30 seconds before you apply for another one. If you use the Alibaba Cloud SMS console, you can apply for an unlimited number of message templates.
     * *   Messages sent to the Chinese mainland and messages sent to countries or regions outside the Chinese mainland use separate message templates. Create message templates based on your needs.
     * *   If you apply for a signature or message template, you must specify the signature scenario or template type. You must also provide the information of your services, such as a website URL, a domain name with an ICP filing, an application download URL, or the name of your WeChat official account or mini program. For sign-in scenarios, you must also provide an account and password for tests. A detailed description can improve the review efficiency of signatures and templates.
     * *   A signature must undergo a thorough review process before it can be approved for use. For more information, see [Usage notes](https://help.aliyun.com/document_detail/55324.html).
     * ### QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @deprecated OpenAPI AddSmsTemplate is deprecated, please use Dysmsapi::2017-05-25::CreateSmsTemplate instead.
     *
     * @param request - AddSmsTemplateRequest
     * @returns AddSmsTemplateResponse
     */
    // Deprecated
    async addSmsTemplate(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.addSmsTemplateWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param request - ChangeSignatureQualificationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ChangeSignatureQualificationResponse
     */
    async changeSignatureQualificationWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.authorizationLetterId)) {
            query["AuthorizationLetterId"] = request.authorizationLetterId;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.qualificationId)) {
            query["QualificationId"] = request.qualificationId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signatureName)) {
            query["SignatureName"] = request.signatureName;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "ChangeSignatureQualification",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new ChangeSignatureQualificationResponse({}));
    }
    /**
     * 
     *
     * @param request - ChangeSignatureQualificationRequest
     * @returns ChangeSignatureQualificationResponse
     */
    async changeSignatureQualification(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.changeSignatureQualificationWithOptions(request, runtime);
    }
    /**
     * Checks whether a mobile phone number can receive card messages.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 2,000 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - CheckMobilesCardSupportRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CheckMobilesCardSupportResponse
     */
    async checkMobilesCardSupportWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.mobiles)) {
            query["Mobiles"] = request.mobiles;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "CheckMobilesCardSupport",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new CheckMobilesCardSupportResponse({}));
    }
    /**
     * Checks whether a mobile phone number can receive card messages.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 2,000 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - CheckMobilesCardSupportRequest
     * @returns CheckMobilesCardSupportResponse
     */
    async checkMobilesCardSupport(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.checkMobilesCardSupportWithOptions(request, runtime);
    }
    /**
     * Sends conversion rate information to Alibaba Cloud SMS.
     *
     * @param request - ConversionDataIntlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ConversionDataIntlResponse
     */
    async conversionDataIntlWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.conversionRate)) {
            query["ConversionRate"] = request.conversionRate;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.reportTime)) {
            query["ReportTime"] = request.reportTime;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "ConversionDataIntl",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new ConversionDataIntlResponse({}));
    }
    /**
     * Sends conversion rate information to Alibaba Cloud SMS.
     *
     * @param request - ConversionDataIntlRequest
     * @returns ConversionDataIntlResponse
     */
    async conversionDataIntl(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.conversionDataIntlWithOptions(request, runtime);
    }
    /**
     * Creates a card message template.
     *
     * @remarks
     *   The CreateCardSmsTemplate operation saves the card message template information, submits it to the mobile phone manufacturer for approval, and returns the message template ID.
     * *   If the type of the message template is not supported or events that are not supported by the mobile phone manufacturer are specified, the template is not submitted. For more information, see [Supported message templates](https://help.aliyun.com/document_detail/434611.html).
     * *   For information about sample card message templates, see [Sample card message templates](https://help.aliyun.com/document_detail/435361.html).
     * ### QPS limit
     * You can call this operation up to 300 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param tmpReq - CreateCardSmsTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateCardSmsTemplateResponse
     */
    async createCardSmsTemplateWithOptions(tmpReq, runtime) {
        tmpReq.validate();
        let request = new CreateCardSmsTemplateShrinkRequest({});
        openapi_core_2.OpenApiUtil.convert(tmpReq, request);
        if (!$dara.isNull(tmpReq.template)) {
            request.templateShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.template, "Template", "json");
        }
        let query = {};
        if (!$dara.isNull(request.factorys)) {
            query["Factorys"] = request.factorys;
        }
        if (!$dara.isNull(request.memo)) {
            query["Memo"] = request.memo;
        }
        if (!$dara.isNull(request.templateShrink)) {
            query["Template"] = request.templateShrink;
        }
        if (!$dara.isNull(request.templateName)) {
            query["TemplateName"] = request.templateName;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "CreateCardSmsTemplate",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new CreateCardSmsTemplateResponse({}));
    }
    /**
     * Creates a card message template.
     *
     * @remarks
     *   The CreateCardSmsTemplate operation saves the card message template information, submits it to the mobile phone manufacturer for approval, and returns the message template ID.
     * *   If the type of the message template is not supported or events that are not supported by the mobile phone manufacturer are specified, the template is not submitted. For more information, see [Supported message templates](https://help.aliyun.com/document_detail/434611.html).
     * *   For information about sample card message templates, see [Sample card message templates](https://help.aliyun.com/document_detail/435361.html).
     * ### QPS limit
     * You can call this operation up to 300 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - CreateCardSmsTemplateRequest
     * @returns CreateCardSmsTemplateResponse
     */
    async createCardSmsTemplate(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.createCardSmsTemplateWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param request - CreateSmartShortUrlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateSmartShortUrlResponse
     */
    async createSmartShortUrlWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.outId)) {
            query["OutId"] = request.outId;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.phoneNumbers)) {
            query["PhoneNumbers"] = request.phoneNumbers;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.sourceUrl)) {
            query["SourceUrl"] = request.sourceUrl;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "CreateSmartShortUrl",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new CreateSmartShortUrlResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateSmartShortUrlRequest
     * @returns CreateSmartShortUrlResponse
     */
    async createSmartShortUrl(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.createSmartShortUrlWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param tmpReq - CreateSmsAuthorizationLetterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateSmsAuthorizationLetterResponse
     */
    async createSmsAuthorizationLetterWithOptions(tmpReq, runtime) {
        tmpReq.validate();
        let request = new CreateSmsAuthorizationLetterShrinkRequest({});
        openapi_core_2.OpenApiUtil.convert(tmpReq, request);
        if (!$dara.isNull(tmpReq.signList)) {
            request.signListShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.signList, "SignList", "json");
        }
        let query = {};
        if (!$dara.isNull(request.authorization)) {
            query["Authorization"] = request.authorization;
        }
        if (!$dara.isNull(request.authorizationLetterExpDate)) {
            query["AuthorizationLetterExpDate"] = request.authorizationLetterExpDate;
        }
        if (!$dara.isNull(request.authorizationLetterName)) {
            query["AuthorizationLetterName"] = request.authorizationLetterName;
        }
        if (!$dara.isNull(request.authorizationLetterPic)) {
            query["AuthorizationLetterPic"] = request.authorizationLetterPic;
        }
        if (!$dara.isNull(request.organizationCode)) {
            query["OrganizationCode"] = request.organizationCode;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.proxyAuthorization)) {
            query["ProxyAuthorization"] = request.proxyAuthorization;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signListShrink)) {
            query["SignList"] = request.signListShrink;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "CreateSmsAuthorizationLetter",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new CreateSmsAuthorizationLetterResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateSmsAuthorizationLetterRequest
     * @returns CreateSmsAuthorizationLetterResponse
     */
    async createSmsAuthorizationLetter(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.createSmsAuthorizationLetterWithOptions(request, runtime);
    }
    /**
     * Create SMS Signature
     *
     * @remarks
     * - For details about the announcement of changes to the new and original interfaces, see [Announcement on Updates to SMS Service Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - Individual authenticated users can apply for one formal signature per natural day under the same Alibaba Cloud account, while enterprise authenticated users have no current restrictions. For details on the differences in rights between individual and enterprise users, please refer to [User Guide](https://help.aliyun.com/zh/sms/user-guide/usage-notes?spm).
     * - Signature information applied through the interface will be synchronized in the SMS service console. For operations related to signatures in the console, see [SMS Signatures](https://help.aliyun.com/zh/sms/user-guide/create-signatures?spm).
     * - After submitting the signature application, you can query the signature review status and details via the [GetSmsSign](https://help.aliyun.com/zh/sms/developer-reference/api-dysmsapi-2017-05-25-getsmssign?spm) interface. You can also [Configure Receipt Messages](https://help.aliyun.com/zh/sms/developer-reference/configure-delivery-receipts-1?spm) and obtain signature review status messages through SignSmsReport.
     *
     * @param tmpReq - CreateSmsSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateSmsSignResponse
     */
    async createSmsSignWithOptions(tmpReq, runtime) {
        tmpReq.validate();
        let request = new CreateSmsSignShrinkRequest({});
        openapi_core_2.OpenApiUtil.convert(tmpReq, request);
        if (!$dara.isNull(tmpReq.moreData)) {
            request.moreDataShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.moreData, "MoreData", "json");
        }
        let query = {};
        if (!$dara.isNull(request.applySceneContent)) {
            query["ApplySceneContent"] = request.applySceneContent;
        }
        if (!$dara.isNull(request.authorizationLetterId)) {
            query["AuthorizationLetterId"] = request.authorizationLetterId;
        }
        if (!$dara.isNull(request.moreDataShrink)) {
            query["MoreData"] = request.moreDataShrink;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.qualificationId)) {
            query["QualificationId"] = request.qualificationId;
        }
        if (!$dara.isNull(request.remark)) {
            query["Remark"] = request.remark;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        if (!$dara.isNull(request.signSource)) {
            query["SignSource"] = request.signSource;
        }
        if (!$dara.isNull(request.signType)) {
            query["SignType"] = request.signType;
        }
        if (!$dara.isNull(request.thirdParty)) {
            query["ThirdParty"] = request.thirdParty;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "CreateSmsSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new CreateSmsSignResponse({}));
    }
    /**
     * Create SMS Signature
     *
     * @remarks
     * - For details about the announcement of changes to the new and original interfaces, see [Announcement on Updates to SMS Service Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - Individual authenticated users can apply for one formal signature per natural day under the same Alibaba Cloud account, while enterprise authenticated users have no current restrictions. For details on the differences in rights between individual and enterprise users, please refer to [User Guide](https://help.aliyun.com/zh/sms/user-guide/usage-notes?spm).
     * - Signature information applied through the interface will be synchronized in the SMS service console. For operations related to signatures in the console, see [SMS Signatures](https://help.aliyun.com/zh/sms/user-guide/create-signatures?spm).
     * - After submitting the signature application, you can query the signature review status and details via the [GetSmsSign](https://help.aliyun.com/zh/sms/developer-reference/api-dysmsapi-2017-05-25-getsmssign?spm) interface. You can also [Configure Receipt Messages](https://help.aliyun.com/zh/sms/developer-reference/configure-delivery-receipts-1?spm) and obtain signature review status messages through SignSmsReport.
     *
     * @param request - CreateSmsSignRequest
     * @returns CreateSmsSignResponse
     */
    async createSmsSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.createSmsSignWithOptions(request, runtime);
    }
    /**
     * Create SMS Template
     *
     * @remarks
     * - For details about the changes of this new interface compared to the original one, please refer to [Announcement on the Update of SMS Service Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - It is recommended to apply for SMS templates via the API with at least a 30-second interval between each request.
     * - The template information applied through the API will be synchronized in the SMS service console. For operations related to templates in the console, please refer to SMS Templates.
     * - After submitting the template application, you can query the audit status and details using the GetSmsTemplate interface. You can also configure delivery receipts to obtain the audit status messages via TemplateSmsReport.
     * - Domestic SMS templates are not interchangeable with international/Hong Kong, Macao, and Taiwan SMS templates. Please apply for templates based on your business scenario.
     * - Only enterprise-verified users can apply for promotional messages and international/Hong Kong, Macao, and Taiwan messages. For differences in rights between personal and enterprise users, please refer to Usage Instructions.
     *
     * @param tmpReq - CreateSmsTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateSmsTemplateResponse
     */
    async createSmsTemplateWithOptions(tmpReq, runtime) {
        tmpReq.validate();
        let request = new CreateSmsTemplateShrinkRequest({});
        openapi_core_2.OpenApiUtil.convert(tmpReq, request);
        if (!$dara.isNull(tmpReq.moreData)) {
            request.moreDataShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.moreData, "MoreData", "json");
        }
        let query = {};
        if (!$dara.isNull(request.applySceneContent)) {
            query["ApplySceneContent"] = request.applySceneContent;
        }
        if (!$dara.isNull(request.intlType)) {
            query["IntlType"] = request.intlType;
        }
        if (!$dara.isNull(request.moreDataShrink)) {
            query["MoreData"] = request.moreDataShrink;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.relatedSignName)) {
            query["RelatedSignName"] = request.relatedSignName;
        }
        if (!$dara.isNull(request.remark)) {
            query["Remark"] = request.remark;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.templateContent)) {
            query["TemplateContent"] = request.templateContent;
        }
        if (!$dara.isNull(request.templateName)) {
            query["TemplateName"] = request.templateName;
        }
        if (!$dara.isNull(request.templateRule)) {
            query["TemplateRule"] = request.templateRule;
        }
        if (!$dara.isNull(request.templateType)) {
            query["TemplateType"] = request.templateType;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "CreateSmsTemplate",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new CreateSmsTemplateResponse({}));
    }
    /**
     * Create SMS Template
     *
     * @remarks
     * - For details about the changes of this new interface compared to the original one, please refer to [Announcement on the Update of SMS Service Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - It is recommended to apply for SMS templates via the API with at least a 30-second interval between each request.
     * - The template information applied through the API will be synchronized in the SMS service console. For operations related to templates in the console, please refer to SMS Templates.
     * - After submitting the template application, you can query the audit status and details using the GetSmsTemplate interface. You can also configure delivery receipts to obtain the audit status messages via TemplateSmsReport.
     * - Domestic SMS templates are not interchangeable with international/Hong Kong, Macao, and Taiwan SMS templates. Please apply for templates based on your business scenario.
     * - Only enterprise-verified users can apply for promotional messages and international/Hong Kong, Macao, and Taiwan messages. For differences in rights between personal and enterprise users, please refer to Usage Instructions.
     *
     * @param request - CreateSmsTemplateRequest
     * @returns CreateSmsTemplateResponse
     */
    async createSmsTemplate(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.createSmsTemplateWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param request - DeleteExtCodeSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteExtCodeSignResponse
     */
    async deleteExtCodeSignWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.extCode)) {
            query["ExtCode"] = request.extCode;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "DeleteExtCodeSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new DeleteExtCodeSignResponse({}));
    }
    /**
     * 
     *
     * @param request - DeleteExtCodeSignRequest
     * @returns DeleteExtCodeSignResponse
     */
    async deleteExtCodeSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.deleteExtCodeSignWithOptions(request, runtime);
    }
    /**
     * Deletes a short URL. After you delete a short URL, it cannot be changed to its original state.
     *
     * @remarks
     * ### QPS limits
     * You can call this operation up to 100 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DeleteShortUrlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteShortUrlResponse
     */
    async deleteShortUrlWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let body = {};
        if (!$dara.isNull(request.sourceUrl)) {
            body["SourceUrl"] = request.sourceUrl;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
            body: openapi_core_2.OpenApiUtil.parseToMap(body),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "DeleteShortUrl",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new DeleteShortUrlResponse({}));
    }
    /**
     * Deletes a short URL. After you delete a short URL, it cannot be changed to its original state.
     *
     * @remarks
     * ### QPS limits
     * You can call this operation up to 100 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DeleteShortUrlRequest
     * @returns DeleteShortUrlResponse
     */
    async deleteShortUrl(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.deleteShortUrlWithOptions(request, runtime);
    }
    /**
     * openAPI
     *
     * @param request - DeleteSmsQualificationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteSmsQualificationResponse
     */
    async deleteSmsQualificationWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.orderId)) {
            query["OrderId"] = request.orderId;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.qualificationGroupId)) {
            query["QualificationGroupId"] = request.qualificationGroupId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "DeleteSmsQualification",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new DeleteSmsQualificationResponse({}));
    }
    /**
     * openAPI
     *
     * @param request - DeleteSmsQualificationRequest
     * @returns DeleteSmsQualificationResponse
     */
    async deleteSmsQualification(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.deleteSmsQualificationWithOptions(request, runtime);
    }
    /**
     * Deletes a signature.
     *
     * @remarks
     *   You cannot delete a signature that has not been approved.
     * *   After you delete a signature, you cannot recover it. Proceed with caution.
     * ### QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DeleteSmsSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteSmsSignResponse
     */
    async deleteSmsSignWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "DeleteSmsSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new DeleteSmsSignResponse({}));
    }
    /**
     * Deletes a signature.
     *
     * @remarks
     *   You cannot delete a signature that has not been approved.
     * *   After you delete a signature, you cannot recover it. Proceed with caution.
     * ### QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DeleteSmsSignRequest
     * @returns DeleteSmsSignResponse
     */
    async deleteSmsSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.deleteSmsSignWithOptions(request, runtime);
    }
    /**
     * Deletes a message template.
     *
     * @remarks
     *   Message templates pending approval can be withdrawn. You can delete a message template pending approval on the Message Templates tab in the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview).
     * *   Message templates that have been approved can be deleted, and cannot be modified. You can delete a message template pending approval on the Message Templates tab in the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview).
     * *   You cannot recover deleted message templates. Proceed with caution.
     * ### QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DeleteSmsTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteSmsTemplateResponse
     */
    async deleteSmsTemplateWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "DeleteSmsTemplate",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new DeleteSmsTemplateResponse({}));
    }
    /**
     * Deletes a message template.
     *
     * @remarks
     *   Message templates pending approval can be withdrawn. You can delete a message template pending approval on the Message Templates tab in the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview).
     * *   Message templates that have been approved can be deleted, and cannot be modified. You can delete a message template pending approval on the Message Templates tab in the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview).
     * *   You cannot recover deleted message templates. Proceed with caution.
     * ### QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DeleteSmsTemplateRequest
     * @returns DeleteSmsTemplateResponse
     */
    async deleteSmsTemplate(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.deleteSmsTemplateWithOptions(request, runtime);
    }
    /**
     * Query card sending details
     *
     * @param request - GetCardSmsDetailsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetCardSmsDetailsResponse
     */
    async getCardSmsDetailsWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.bizCardId)) {
            query["BizCardId"] = request.bizCardId;
        }
        if (!$dara.isNull(request.bizDigitId)) {
            query["BizDigitId"] = request.bizDigitId;
        }
        if (!$dara.isNull(request.bizSmsId)) {
            query["BizSmsId"] = request.bizSmsId;
        }
        if (!$dara.isNull(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!$dara.isNull(request.phoneNumber)) {
            query["PhoneNumber"] = request.phoneNumber;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.sendDate)) {
            query["SendDate"] = request.sendDate;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "GetCardSmsDetails",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new GetCardSmsDetailsResponse({}));
    }
    /**
     * Query card sending details
     *
     * @param request - GetCardSmsDetailsRequest
     * @returns GetCardSmsDetailsResponse
     */
    async getCardSmsDetails(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.getCardSmsDetailsWithOptions(request, runtime);
    }
    /**
     * Queries the short URLs of a card messages template.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 1,000 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetCardSmsLinkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetCardSmsLinkResponse
     */
    async getCardSmsLinkWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.cardCodeType)) {
            query["CardCodeType"] = request.cardCodeType;
        }
        if (!$dara.isNull(request.cardLinkType)) {
            query["CardLinkType"] = request.cardLinkType;
        }
        if (!$dara.isNull(request.cardTemplateCode)) {
            query["CardTemplateCode"] = request.cardTemplateCode;
        }
        if (!$dara.isNull(request.cardTemplateParamJson)) {
            query["CardTemplateParamJson"] = request.cardTemplateParamJson;
        }
        if (!$dara.isNull(request.customShortCodeJson)) {
            query["CustomShortCodeJson"] = request.customShortCodeJson;
        }
        if (!$dara.isNull(request.domain)) {
            query["Domain"] = request.domain;
        }
        if (!$dara.isNull(request.outId)) {
            query["OutId"] = request.outId;
        }
        if (!$dara.isNull(request.phoneNumberJson)) {
            query["PhoneNumberJson"] = request.phoneNumberJson;
        }
        if (!$dara.isNull(request.signNameJson)) {
            query["SignNameJson"] = request.signNameJson;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "GetCardSmsLink",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new GetCardSmsLinkResponse({}));
    }
    /**
     * Queries the short URLs of a card messages template.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 1,000 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetCardSmsLinkRequest
     * @returns GetCardSmsLinkResponse
     */
    async getCardSmsLink(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.getCardSmsLinkWithOptions(request, runtime);
    }
    /**
     * Converts a resource uploaded to the specified Object Storage Service (OSS) bucket for unified management. Then, a resource ID is returned. You can manage the resource based on the ID.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 300 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetMediaResourceIdRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetMediaResourceIdResponse
     */
    async getMediaResourceIdWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.extendInfo)) {
            query["ExtendInfo"] = request.extendInfo;
        }
        if (!$dara.isNull(request.fileSize)) {
            query["FileSize"] = request.fileSize;
        }
        if (!$dara.isNull(request.memo)) {
            query["Memo"] = request.memo;
        }
        if (!$dara.isNull(request.ossKey)) {
            query["OssKey"] = request.ossKey;
        }
        if (!$dara.isNull(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "GetMediaResourceId",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new GetMediaResourceIdResponse({}));
    }
    /**
     * Converts a resource uploaded to the specified Object Storage Service (OSS) bucket for unified management. Then, a resource ID is returned. You can manage the resource based on the ID.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 300 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetMediaResourceIdRequest
     * @returns GetMediaResourceIdResponse
     */
    async getMediaResourceId(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.getMediaResourceIdWithOptions(request, runtime);
    }
    /**
     * Queries the OSS configuration information about card messages.
     *
     * @remarks
     * Resources such as images and videos used for card message templates can be uploaded to Object Storage Service (OSS) buckets for storage. For more information, see [Upload files to OSS](https://help.aliyun.com/document_detail/437303.html).
     * ### QPS limit
     * You can call this operation up to 300 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetOSSInfoForCardTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetOSSInfoForCardTemplateResponse
     */
    async getOSSInfoForCardTemplateWithOptions(runtime) {
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({});
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "GetOSSInfoForCardTemplate",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new GetOSSInfoForCardTemplateResponse({}));
    }
    /**
     * Queries the OSS configuration information about card messages.
     *
     * @remarks
     * Resources such as images and videos used for card message templates can be uploaded to Object Storage Service (OSS) buckets for storage. For more information, see [Upload files to OSS](https://help.aliyun.com/document_detail/437303.html).
     * ### QPS limit
     * You can call this operation up to 300 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     * @returns GetOSSInfoForCardTemplateResponse
     */
    async getOSSInfoForCardTemplate() {
        let runtime = new $dara.RuntimeOptions({});
        return await this.getOSSInfoForCardTemplateWithOptions(runtime);
    }
    /**
     * SMS File Upload, Get Authorization Info
     *
     * @remarks
     * - When creating signatures or templates, you can upload materials such as login pages with links, backend page screenshots, software copyrights, supplementary agreements, etc. This helps the review personnel understand your business details. If there are multiple materials, they can be combined into one file, supporting png, jpg, jpeg, doc, docx, pdf formats.
     * - For additional materials needed when creating signatures or templates, you can upload them to the OSS file system for storage. For file upload operations, refer to [OSS File Upload](https://help.aliyun.com/zh/sms/upload-files-through-oss).
     *
     * @param request - GetOSSInfoForUploadFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetOSSInfoForUploadFileResponse
     */
    async getOSSInfoForUploadFileWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.bizType)) {
            query["BizType"] = request.bizType;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "GetOSSInfoForUploadFile",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new GetOSSInfoForUploadFileResponse({}));
    }
    /**
     * SMS File Upload, Get Authorization Info
     *
     * @remarks
     * - When creating signatures or templates, you can upload materials such as login pages with links, backend page screenshots, software copyrights, supplementary agreements, etc. This helps the review personnel understand your business details. If there are multiple materials, they can be combined into one file, supporting png, jpg, jpeg, doc, docx, pdf formats.
     * - For additional materials needed when creating signatures or templates, you can upload them to the OSS file system for storage. For file upload operations, refer to [OSS File Upload](https://help.aliyun.com/zh/sms/upload-files-through-oss).
     *
     * @param request - GetOSSInfoForUploadFileRequest
     * @returns GetOSSInfoForUploadFileResponse
     */
    async getOSSInfoForUploadFile(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.getOSSInfoForUploadFileWithOptions(request, runtime);
    }
    /**
     * oss
     *
     * @param request - GetQualificationOssInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetQualificationOssInfoResponse
     */
    async getQualificationOssInfoWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.bizType)) {
            query["BizType"] = request.bizType;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "GetQualificationOssInfo",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new GetQualificationOssInfoResponse({}));
    }
    /**
     * oss
     *
     * @param request - GetQualificationOssInfoRequest
     * @returns GetQualificationOssInfoResponse
     */
    async getQualificationOssInfo(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.getQualificationOssInfoWithOptions(request, runtime);
    }
    /**
     * Query SMS Signature Details
     *
     * @remarks
     * - For details about the changes of this new interface and the original one, please refer to [Announcement on the Update of SMS Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - Review Time: Generally, after submitting the signature, Alibaba Cloud expects to complete the review within 2 hours (Review Business Hours: Monday to Sunday 9:00~21:00, with legal holidays postponed). It is recommended to submit your application before 18:00.
     * - If the signature fails the review, the reason for the failure will be returned. Please refer to [Handling Suggestions for Failed SMS Reviews](https://help.aliyun.com/zh/sms/user-guide/causes-of-application-failures-and-suggestions?spm), invoke the [UpdateSmsSign](https://help.aliyun.com/zh/sms/developer-reference/api-dysmsapi-2017-05-25-updatesmssign?spm) API, or modify the unapproved SMS signature on the [Signature Management](https://dysms.console.aliyun.com/domestic/text/sign) page.
     *
     * @param request - GetSmsSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetSmsSignResponse
     */
    async getSmsSignWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "GetSmsSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new GetSmsSignResponse({}));
    }
    /**
     * Query SMS Signature Details
     *
     * @remarks
     * - For details about the changes of this new interface and the original one, please refer to [Announcement on the Update of SMS Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - Review Time: Generally, after submitting the signature, Alibaba Cloud expects to complete the review within 2 hours (Review Business Hours: Monday to Sunday 9:00~21:00, with legal holidays postponed). It is recommended to submit your application before 18:00.
     * - If the signature fails the review, the reason for the failure will be returned. Please refer to [Handling Suggestions for Failed SMS Reviews](https://help.aliyun.com/zh/sms/user-guide/causes-of-application-failures-and-suggestions?spm), invoke the [UpdateSmsSign](https://help.aliyun.com/zh/sms/developer-reference/api-dysmsapi-2017-05-25-updatesmssign?spm) API, or modify the unapproved SMS signature on the [Signature Management](https://dysms.console.aliyun.com/domestic/text/sign) page.
     *
     * @param request - GetSmsSignRequest
     * @returns GetSmsSignResponse
     */
    async getSmsSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.getSmsSignWithOptions(request, runtime);
    }
    /**
     * Query Text SMS Template Details
     *
     * @remarks
     * - For details about the announcement of changes to the new and original interfaces, see [Announcement on Updates to SMS Service Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - Review Time: Under normal circumstances, Alibaba Cloud expects to complete the review within 2 hours after template submission (review working hours: Monday to Sunday 9:00~21:00, with statutory holidays postponed). It is recommended to submit your application before 18:00.
     * - If the template fails the review, the reason for the failure will be returned. Please refer to [Handling Suggestions for Failed SMS Reviews](https://help.aliyun.com/zh/sms/user-guide/causes-of-application-failures-and-suggestions?spm=a2c4g.11186623.0.0.41fd339f3bPSCQ), invoke the [ModifySmsTemplate](https://help.aliyun.com/zh/sms/developer-reference/api-dysmsapi-2017-05-25-modifysmstemplate?spm=a2c4g.11186623.0.0.5b1f6e8bQloFit) API or modify the SMS template on the [Template Management](https://dysms.console.aliyun.com/domestic/text/template) page.
     * - The current QuerySmsTemplate interface queries the audit details of a single template by template code. The [QuerySmsTemplateList](https://help.aliyun.com/zh/sms/developer-reference/api-dysmsapi-2017-05-25-querysmstemplatelist?spm=a2c4g.11186623.0.0.24086e8bO8cFn4) interface can query the template details of all templates under your current account.
     *
     * @param request - GetSmsTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetSmsTemplateResponse
     */
    async getSmsTemplateWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "GetSmsTemplate",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new GetSmsTemplateResponse({}));
    }
    /**
     * Query Text SMS Template Details
     *
     * @remarks
     * - For details about the announcement of changes to the new and original interfaces, see [Announcement on Updates to SMS Service Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - Review Time: Under normal circumstances, Alibaba Cloud expects to complete the review within 2 hours after template submission (review working hours: Monday to Sunday 9:00~21:00, with statutory holidays postponed). It is recommended to submit your application before 18:00.
     * - If the template fails the review, the reason for the failure will be returned. Please refer to [Handling Suggestions for Failed SMS Reviews](https://help.aliyun.com/zh/sms/user-guide/causes-of-application-failures-and-suggestions?spm=a2c4g.11186623.0.0.41fd339f3bPSCQ), invoke the [ModifySmsTemplate](https://help.aliyun.com/zh/sms/developer-reference/api-dysmsapi-2017-05-25-modifysmstemplate?spm=a2c4g.11186623.0.0.5b1f6e8bQloFit) API or modify the SMS template on the [Template Management](https://dysms.console.aliyun.com/domestic/text/template) page.
     * - The current QuerySmsTemplate interface queries the audit details of a single template by template code. The [QuerySmsTemplateList](https://help.aliyun.com/zh/sms/developer-reference/api-dysmsapi-2017-05-25-querysmstemplatelist?spm=a2c4g.11186623.0.0.24086e8bO8cFn4) interface can query the template details of all templates under your current account.
     *
     * @param request - GetSmsTemplateRequest
     * @returns GetSmsTemplateResponse
     */
    async getSmsTemplate(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.getSmsTemplateWithOptions(request, runtime);
    }
    /**
     * Queries the tags of a message template.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ListTagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListTagResourcesResponse
     */
    async listTagResourcesWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!$dara.isNull(request.prodCode)) {
            query["ProdCode"] = request.prodCode;
        }
        if (!$dara.isNull(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!$dara.isNull(request.resourceId)) {
            query["ResourceId"] = request.resourceId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!$dara.isNull(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "ListTagResources",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
    }
    /**
     * Queries the tags of a message template.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ListTagResourcesRequest
     * @returns ListTagResourcesResponse
     */
    async listTagResources(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.listTagResourcesWithOptions(request, runtime);
    }
    /**
     * Modifies a rejected signature and submit it for approval. Signatures that are pending approval or have been approved cannot be modified.
     *
     * @remarks
     * You can call the operation or use the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview) to modify an existing signature and submit the signature for approval. The signature must comply with the [signature specifications](https://help.aliyun.com/document_detail/108076.html).
     * For more information, see [Usage notes](https://help.aliyun.com/document_detail/55324.html).
     * ### QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     * >
     * *   Signatures pending approval cannot be modified.
     * *   You cannot modify a signature after it is approved. If you no longer need the signature, you can delete it.
     * *   If you are an individual user, you cannot apply for a new signature on the same day that your signature is rejected or deleted. We recommend that you modify the rejected signature and submit it again.
     *
     * @param request - ModifySmsSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ModifySmsSignResponse
     */
    async modifySmsSignWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.remark)) {
            query["Remark"] = request.remark;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        if (!$dara.isNull(request.signSource)) {
            query["SignSource"] = request.signSource;
        }
        if (!$dara.isNull(request.signType)) {
            query["SignType"] = request.signType;
        }
        let body = {};
        if (!$dara.isNull(request.signFileList)) {
            body["SignFileList"] = request.signFileList;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
            body: openapi_core_2.OpenApiUtil.parseToMap(body),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "ModifySmsSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new ModifySmsSignResponse({}));
    }
    /**
     * Modifies a rejected signature and submit it for approval. Signatures that are pending approval or have been approved cannot be modified.
     *
     * @remarks
     * You can call the operation or use the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm#/overview) to modify an existing signature and submit the signature for approval. The signature must comply with the [signature specifications](https://help.aliyun.com/document_detail/108076.html).
     * For more information, see [Usage notes](https://help.aliyun.com/document_detail/55324.html).
     * ### QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     * >
     * *   Signatures pending approval cannot be modified.
     * *   You cannot modify a signature after it is approved. If you no longer need the signature, you can delete it.
     * *   If you are an individual user, you cannot apply for a new signature on the same day that your signature is rejected or deleted. We recommend that you modify the rejected signature and submit it again.
     *
     * @param request - ModifySmsSignRequest
     * @returns ModifySmsSignResponse
     */
    async modifySmsSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.modifySmsSignWithOptions(request, runtime);
    }
    /**
     * Modifies the information of an unapproved message template and submits it for review again.
     *
     * @remarks
     * After you apply for a message template, if the template fails to pass the review, you can call this operation to modify the template and submit the template again. You can call this operation to modify only a template for a specific message type.
     * The template content must comply with the [SMS template specifications](https://help.aliyun.com/document_detail/108253.html).
     * For more information, see [Usage notes](https://help.aliyun.com/document_detail/55324.html).
     * ### QPS limit
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @deprecated OpenAPI ModifySmsTemplate is deprecated, please use Dysmsapi::2017-05-25::UpdateSmsTemplate instead.
     *
     * @param request - ModifySmsTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ModifySmsTemplateResponse
     */
    // Deprecated
    async modifySmsTemplateWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.remark)) {
            query["Remark"] = request.remark;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        if (!$dara.isNull(request.templateContent)) {
            query["TemplateContent"] = request.templateContent;
        }
        if (!$dara.isNull(request.templateName)) {
            query["TemplateName"] = request.templateName;
        }
        if (!$dara.isNull(request.templateType)) {
            query["TemplateType"] = request.templateType;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "ModifySmsTemplate",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new ModifySmsTemplateResponse({}));
    }
    /**
     * Modifies the information of an unapproved message template and submits it for review again.
     *
     * @remarks
     * After you apply for a message template, if the template fails to pass the review, you can call this operation to modify the template and submit the template again. You can call this operation to modify only a template for a specific message type.
     * The template content must comply with the [SMS template specifications](https://help.aliyun.com/document_detail/108253.html).
     * For more information, see [Usage notes](https://help.aliyun.com/document_detail/55324.html).
     * ### QPS limit
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @deprecated OpenAPI ModifySmsTemplate is deprecated, please use Dysmsapi::2017-05-25::UpdateSmsTemplate instead.
     *
     * @param request - ModifySmsTemplateRequest
     * @returns ModifySmsTemplateResponse
     */
    // Deprecated
    async modifySmsTemplate(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.modifySmsTemplateWithOptions(request, runtime);
    }
    /**
     * Queries the review status of a message template.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 300 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryCardSmsTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryCardSmsTemplateResponse
     */
    async queryCardSmsTemplateWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QueryCardSmsTemplate",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QueryCardSmsTemplateResponse({}));
    }
    /**
     * Queries the review status of a message template.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 300 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryCardSmsTemplateRequest
     * @returns QueryCardSmsTemplateResponse
     */
    async queryCardSmsTemplate(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.queryCardSmsTemplateWithOptions(request, runtime);
    }
    /**
     * Queries sent card messages.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 300 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryCardSmsTemplateReportRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryCardSmsTemplateReportResponse
     */
    async queryCardSmsTemplateReportWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.endDate)) {
            query["EndDate"] = request.endDate;
        }
        if (!$dara.isNull(request.startDate)) {
            query["StartDate"] = request.startDate;
        }
        if (!$dara.isNull(request.templateCodes)) {
            query["TemplateCodes"] = request.templateCodes;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QueryCardSmsTemplateReport",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QueryCardSmsTemplateReportResponse({}));
    }
    /**
     * Queries sent card messages.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 300 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryCardSmsTemplateReportRequest
     * @returns QueryCardSmsTemplateReportResponse
     */
    async queryCardSmsTemplateReport(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.queryCardSmsTemplateReportWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param request - QueryExtCodeSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryExtCodeSignResponse
     */
    async queryExtCodeSignWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.extCode)) {
            query["ExtCode"] = request.extCode;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.pageNo)) {
            query["PageNo"] = request.pageNo;
        }
        if (!$dara.isNull(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QueryExtCodeSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QueryExtCodeSignResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryExtCodeSignRequest
     * @returns QueryExtCodeSignResponse
     */
    async queryExtCodeSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.queryExtCodeSignWithOptions(request, runtime);
    }
    /**
     * Checks whether a mobile phone number can receive card messages.
     *
     * @param tmpReq - QueryMobilesCardSupportRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryMobilesCardSupportResponse
     */
    async queryMobilesCardSupportWithOptions(tmpReq, runtime) {
        tmpReq.validate();
        let request = new QueryMobilesCardSupportShrinkRequest({});
        openapi_core_2.OpenApiUtil.convert(tmpReq, request);
        if (!$dara.isNull(tmpReq.mobiles)) {
            request.mobilesShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.mobiles, "Mobiles", "json");
        }
        let query = {};
        if (!$dara.isNull(request.mobilesShrink)) {
            query["Mobiles"] = request.mobilesShrink;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QueryMobilesCardSupport",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QueryMobilesCardSupportResponse({}));
    }
    /**
     * Checks whether a mobile phone number can receive card messages.
     *
     * @param request - QueryMobilesCardSupportRequest
     * @returns QueryMobilesCardSupportResponse
     */
    async queryMobilesCardSupport(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.queryMobilesCardSupportWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param request - QueryPageSmartShortUrlLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryPageSmartShortUrlLogResponse
     */
    async queryPageSmartShortUrlLogWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.createDateEnd)) {
            query["CreateDateEnd"] = request.createDateEnd;
        }
        if (!$dara.isNull(request.createDateStart)) {
            query["CreateDateStart"] = request.createDateStart;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.pageNo)) {
            query["PageNo"] = request.pageNo;
        }
        if (!$dara.isNull(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!$dara.isNull(request.phoneNumber)) {
            query["PhoneNumber"] = request.phoneNumber;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.shortUrl)) {
            query["ShortUrl"] = request.shortUrl;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QueryPageSmartShortUrlLog",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QueryPageSmartShortUrlLogResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryPageSmartShortUrlLogRequest
     * @returns QueryPageSmartShortUrlLogResponse
     */
    async queryPageSmartShortUrlLog(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.queryPageSmartShortUrlLogWithOptions(request, runtime);
    }
    /**
     * Queries the information about a message.
     *
     * @param request - QuerySendDetailsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySendDetailsResponse
     */
    async querySendDetailsWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.bizId)) {
            query["BizId"] = request.bizId;
        }
        if (!$dara.isNull(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!$dara.isNull(request.phoneNumber)) {
            query["PhoneNumber"] = request.phoneNumber;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.sendDate)) {
            query["SendDate"] = request.sendDate;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QuerySendDetails",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QuerySendDetailsResponse({}));
    }
    /**
     * Queries the information about a message.
     *
     * @param request - QuerySendDetailsRequest
     * @returns QuerySendDetailsResponse
     */
    async querySendDetails(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.querySendDetailsWithOptions(request, runtime);
    }
    /**
     * Queries message delivery details.
     *
     * @remarks
     * You can call the operation to query message delivery details, including the number of delivered messages, the number of messages with delivery receipts, and the time that a message is sent. If a large number of messages are sent on the specified date, you can specify the number of items displayed on each page and the number of pages to view the details by page.
     * ### QPS limits
     * You can call this operation up to 20 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QuerySendStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySendStatisticsResponse
     */
    async querySendStatisticsWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.endDate)) {
            query["EndDate"] = request.endDate;
        }
        if (!$dara.isNull(request.isGlobe)) {
            query["IsGlobe"] = request.isGlobe;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.pageIndex)) {
            query["PageIndex"] = request.pageIndex;
        }
        if (!$dara.isNull(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        if (!$dara.isNull(request.startDate)) {
            query["StartDate"] = request.startDate;
        }
        if (!$dara.isNull(request.templateType)) {
            query["TemplateType"] = request.templateType;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QuerySendStatistics",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QuerySendStatisticsResponse({}));
    }
    /**
     * Queries message delivery details.
     *
     * @remarks
     * You can call the operation to query message delivery details, including the number of delivered messages, the number of messages with delivery receipts, and the time that a message is sent. If a large number of messages are sent on the specified date, you can specify the number of items displayed on each page and the number of pages to view the details by page.
     * ### QPS limits
     * You can call this operation up to 20 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QuerySendStatisticsRequest
     * @returns QuerySendStatisticsResponse
     */
    async querySendStatistics(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.querySendStatisticsWithOptions(request, runtime);
    }
    /**
     * Queries the status of a short URL.
     *
     * @remarks
     * ### QPS limits
     * You can call this operation up to 20 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryShortUrlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryShortUrlResponse
     */
    async queryShortUrlWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let body = {};
        if (!$dara.isNull(request.shortUrl)) {
            body["ShortUrl"] = request.shortUrl;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
            body: openapi_core_2.OpenApiUtil.parseToMap(body),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QueryShortUrl",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QueryShortUrlResponse({}));
    }
    /**
     * Queries the status of a short URL.
     *
     * @remarks
     * ### QPS limits
     * You can call this operation up to 20 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryShortUrlRequest
     * @returns QueryShortUrlResponse
     */
    async queryShortUrl(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.queryShortUrlWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param request - QuerySingleSmsQualificationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySingleSmsQualificationResponse
     */
    async querySingleSmsQualificationWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.orderId)) {
            query["OrderId"] = request.orderId;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.qualificationGroupId)) {
            query["QualificationGroupId"] = request.qualificationGroupId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QuerySingleSmsQualification",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QuerySingleSmsQualificationResponse({}));
    }
    /**
     * 
     *
     * @param request - QuerySingleSmsQualificationRequest
     * @returns QuerySingleSmsQualificationResponse
     */
    async querySingleSmsQualification(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.querySingleSmsQualificationWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param tmpReq - QuerySmsAuthorizationLetterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySmsAuthorizationLetterResponse
     */
    async querySmsAuthorizationLetterWithOptions(tmpReq, runtime) {
        tmpReq.validate();
        let request = new QuerySmsAuthorizationLetterShrinkRequest({});
        openapi_core_2.OpenApiUtil.convert(tmpReq, request);
        if (!$dara.isNull(tmpReq.authorizationLetterIdList)) {
            request.authorizationLetterIdListShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authorizationLetterIdList, "AuthorizationLetterIdList", "json");
        }
        let query = {};
        if (!$dara.isNull(request.authorizationLetterIdListShrink)) {
            query["AuthorizationLetterIdList"] = request.authorizationLetterIdListShrink;
        }
        if (!$dara.isNull(request.organizationCode)) {
            query["OrganizationCode"] = request.organizationCode;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        if (!$dara.isNull(request.state)) {
            query["State"] = request.state;
        }
        if (!$dara.isNull(request.status)) {
            query["Status"] = request.status;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QuerySmsAuthorizationLetter",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QuerySmsAuthorizationLetterResponse({}));
    }
    /**
     * 
     *
     * @param request - QuerySmsAuthorizationLetterRequest
     * @returns QuerySmsAuthorizationLetterResponse
     */
    async querySmsAuthorizationLetter(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.querySmsAuthorizationLetterWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param request - QuerySmsQualificationRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySmsQualificationRecordResponse
     */
    async querySmsQualificationRecordWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.companyName)) {
            query["CompanyName"] = request.companyName;
        }
        if (!$dara.isNull(request.legalPersonName)) {
            query["LegalPersonName"] = request.legalPersonName;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.pageNo)) {
            query["PageNo"] = request.pageNo;
        }
        if (!$dara.isNull(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!$dara.isNull(request.qualificationGroupName)) {
            query["QualificationGroupName"] = request.qualificationGroupName;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.state)) {
            query["State"] = request.state;
        }
        if (!$dara.isNull(request.useBySelf)) {
            query["UseBySelf"] = request.useBySelf;
        }
        if (!$dara.isNull(request.workOrderId)) {
            query["WorkOrderId"] = request.workOrderId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QuerySmsQualificationRecord",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QuerySmsQualificationRecordResponse({}));
    }
    /**
     * 
     *
     * @param request - QuerySmsQualificationRecordRequest
     * @returns QuerySmsQualificationRecordResponse
     */
    async querySmsQualificationRecord(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.querySmsQualificationRecordWithOptions(request, runtime);
    }
    /**
     * Queries the status of a signature.
     *
     * @remarks
     * After you apply for an SMS signature, you can query its status by using the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm) or calling the operation. If the signature is rejected, you can modify the signature based on the reason why it is rejected.
     * ### QPS limits
     * You can call this API operation up to 500 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QuerySmsSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySmsSignResponse
     */
    async querySmsSignWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QuerySmsSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QuerySmsSignResponse({}));
    }
    /**
     * Queries the status of a signature.
     *
     * @remarks
     * After you apply for an SMS signature, you can query its status by using the [Alibaba Cloud SMS console](https://dysms.console.aliyun.com/dysms.htm) or calling the operation. If the signature is rejected, you can modify the signature based on the reason why it is rejected.
     * ### QPS limits
     * You can call this API operation up to 500 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QuerySmsSignRequest
     * @returns QuerySmsSignResponse
     */
    async querySmsSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.querySmsSignWithOptions(request, runtime);
    }
    /**
     * Queries message signatures by page.
     *
     * @remarks
     * You can call this operation to query the details of message signatures, including the name, creation time, and approval status of each signature. If a message template is rejected, the reason is returned. Modify the message signature based on the reason.
     * ### QPS limit
     * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QuerySmsSignListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySmsSignListResponse
     */
    async querySmsSignListWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.pageIndex)) {
            query["PageIndex"] = request.pageIndex;
        }
        if (!$dara.isNull(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QuerySmsSignList",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QuerySmsSignListResponse({}));
    }
    /**
     * Queries message signatures by page.
     *
     * @remarks
     * You can call this operation to query the details of message signatures, including the name, creation time, and approval status of each signature. If a message template is rejected, the reason is returned. Modify the message signature based on the reason.
     * ### QPS limit
     * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QuerySmsSignListRequest
     * @returns QuerySmsSignListResponse
     */
    async querySmsSignList(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.querySmsSignListWithOptions(request, runtime);
    }
    /**
     * Queries the approval status of a message template.
     *
     * @remarks
     * After you create a message template, you can call this operation to query the approval status of the template. If a message template is rejected, the reason is returned. Modify the message template based on the reason.
     * ### QPS limit
     * You can call this operation up to 5,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @deprecated OpenAPI QuerySmsTemplate is deprecated, please use Dysmsapi::2017-05-25::GetSmsTemplate instead.
     *
     * @param request - QuerySmsTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySmsTemplateResponse
     */
    // Deprecated
    async querySmsTemplateWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QuerySmsTemplate",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QuerySmsTemplateResponse({}));
    }
    /**
     * Queries the approval status of a message template.
     *
     * @remarks
     * After you create a message template, you can call this operation to query the approval status of the template. If a message template is rejected, the reason is returned. Modify the message template based on the reason.
     * ### QPS limit
     * You can call this operation up to 5,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @deprecated OpenAPI QuerySmsTemplate is deprecated, please use Dysmsapi::2017-05-25::GetSmsTemplate instead.
     *
     * @param request - QuerySmsTemplateRequest
     * @returns QuerySmsTemplateResponse
     */
    // Deprecated
    async querySmsTemplate(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.querySmsTemplateWithOptions(request, runtime);
    }
    /**
     * Queries message templates.
     *
     * @remarks
     * You can call this operation to query the details of message templates, including the name, creation time, and approval status of each template. If a message template is rejected, the reason is returned. Modify the message template based on the reason.
     * ### QPS limit
     * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QuerySmsTemplateListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySmsTemplateListResponse
     */
    async querySmsTemplateListWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.pageIndex)) {
            query["PageIndex"] = request.pageIndex;
        }
        if (!$dara.isNull(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "QuerySmsTemplateList",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new QuerySmsTemplateListResponse({}));
    }
    /**
     * Queries message templates.
     *
     * @remarks
     * You can call this operation to query the details of message templates, including the name, creation time, and approval status of each template. If a message template is rejected, the reason is returned. Modify the message template based on the reason.
     * ### QPS limit
     * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QuerySmsTemplateListRequest
     * @returns QuerySmsTemplateListResponse
     */
    async querySmsTemplateList(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.querySmsTemplateListWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param request - RequiredPhoneCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RequiredPhoneCodeResponse
     */
    async requiredPhoneCodeWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.phoneNo)) {
            query["PhoneNo"] = request.phoneNo;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "RequiredPhoneCode",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new RequiredPhoneCodeResponse({}));
    }
    /**
     * 
     *
     * @param request - RequiredPhoneCodeRequest
     * @returns RequiredPhoneCodeResponse
     */
    async requiredPhoneCode(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.requiredPhoneCodeWithOptions(request, runtime);
    }
    /**
     * Sends multiple card messages at a time.
     *
     * @remarks
     * You can call the operation to send multiple card messages to a maximum of mobile phone numbers at a time. Different signatures and rollback settings can be specified for the mobile phone numbers.
     * ### QPS limit
     * You can call this operation up to 1,000 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - SendBatchCardSmsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendBatchCardSmsResponse
     */
    async sendBatchCardSmsWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.cardTemplateCode)) {
            query["CardTemplateCode"] = request.cardTemplateCode;
        }
        if (!$dara.isNull(request.cardTemplateParamJson)) {
            query["CardTemplateParamJson"] = request.cardTemplateParamJson;
        }
        if (!$dara.isNull(request.digitalTemplateCode)) {
            query["DigitalTemplateCode"] = request.digitalTemplateCode;
        }
        if (!$dara.isNull(request.digitalTemplateParamJson)) {
            query["DigitalTemplateParamJson"] = request.digitalTemplateParamJson;
        }
        if (!$dara.isNull(request.fallbackType)) {
            query["FallbackType"] = request.fallbackType;
        }
        if (!$dara.isNull(request.outId)) {
            query["OutId"] = request.outId;
        }
        if (!$dara.isNull(request.phoneNumberJson)) {
            query["PhoneNumberJson"] = request.phoneNumberJson;
        }
        if (!$dara.isNull(request.signNameJson)) {
            query["SignNameJson"] = request.signNameJson;
        }
        if (!$dara.isNull(request.smsTemplateCode)) {
            query["SmsTemplateCode"] = request.smsTemplateCode;
        }
        if (!$dara.isNull(request.smsTemplateParamJson)) {
            query["SmsTemplateParamJson"] = request.smsTemplateParamJson;
        }
        if (!$dara.isNull(request.smsUpExtendCodeJson)) {
            query["SmsUpExtendCodeJson"] = request.smsUpExtendCodeJson;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        if (!$dara.isNull(request.templateParamJson)) {
            query["TemplateParamJson"] = request.templateParamJson;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "SendBatchCardSms",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new SendBatchCardSmsResponse({}));
    }
    /**
     * Sends multiple card messages at a time.
     *
     * @remarks
     * You can call the operation to send multiple card messages to a maximum of mobile phone numbers at a time. Different signatures and rollback settings can be specified for the mobile phone numbers.
     * ### QPS limit
     * You can call this operation up to 1,000 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - SendBatchCardSmsRequest
     * @returns SendBatchCardSmsResponse
     */
    async sendBatchCardSms(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.sendBatchCardSmsWithOptions(request, runtime);
    }
    /**
     * Uses a single message template and multiple signatures to send messages to multiple recipients.
     *
     * @remarks
     * You can call the operation to send messages to a maximum of 100 recipients at a time.
     *
     * @param request - SendBatchSmsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendBatchSmsResponse
     */
    async sendBatchSmsWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.outId)) {
            query["OutId"] = request.outId;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        let body = {};
        if (!$dara.isNull(request.phoneNumberJson)) {
            body["PhoneNumberJson"] = request.phoneNumberJson;
        }
        if (!$dara.isNull(request.signNameJson)) {
            body["SignNameJson"] = request.signNameJson;
        }
        if (!$dara.isNull(request.smsUpExtendCodeJson)) {
            body["SmsUpExtendCodeJson"] = request.smsUpExtendCodeJson;
        }
        if (!$dara.isNull(request.templateParamJson)) {
            body["TemplateParamJson"] = request.templateParamJson;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
            body: openapi_core_2.OpenApiUtil.parseToMap(body),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "SendBatchSms",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new SendBatchSmsResponse({}));
    }
    /**
     * Uses a single message template and multiple signatures to send messages to multiple recipients.
     *
     * @remarks
     * You can call the operation to send messages to a maximum of 100 recipients at a time.
     *
     * @param request - SendBatchSmsRequest
     * @returns SendBatchSmsResponse
     */
    async sendBatchSms(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.sendBatchSmsWithOptions(request, runtime);
    }
    /**
     * Sends a card message.
     *
     * @remarks
     *   Make sure that the message template that you want to use has been approved. If the mobile phone number of a recipient does not support card messages, the SendCardSms operation allows the rollback feature to ensure successful delivery.
     * *   When you call the SendCardSms operation to send card messages, the operation checks whether the mobile phone numbers of the recipients support card messages. If the mobile phone numbers do not support card messages, you can specify whether to enable rollback. Otherwise, the card message cannot be delivered.
     * ### QPS limit
     * You can call this operation up to 1,000 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - SendCardSmsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendCardSmsResponse
     */
    async sendCardSmsWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.cardObjects)) {
            query["CardObjects"] = request.cardObjects;
        }
        if (!$dara.isNull(request.cardTemplateCode)) {
            query["CardTemplateCode"] = request.cardTemplateCode;
        }
        if (!$dara.isNull(request.digitalTemplateCode)) {
            query["DigitalTemplateCode"] = request.digitalTemplateCode;
        }
        if (!$dara.isNull(request.digitalTemplateParam)) {
            query["DigitalTemplateParam"] = request.digitalTemplateParam;
        }
        if (!$dara.isNull(request.fallbackType)) {
            query["FallbackType"] = request.fallbackType;
        }
        if (!$dara.isNull(request.outId)) {
            query["OutId"] = request.outId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        if (!$dara.isNull(request.smsTemplateCode)) {
            query["SmsTemplateCode"] = request.smsTemplateCode;
        }
        if (!$dara.isNull(request.smsTemplateParam)) {
            query["SmsTemplateParam"] = request.smsTemplateParam;
        }
        if (!$dara.isNull(request.smsUpExtendCode)) {
            query["SmsUpExtendCode"] = request.smsUpExtendCode;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        if (!$dara.isNull(request.templateParam)) {
            query["TemplateParam"] = request.templateParam;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "SendCardSms",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new SendCardSmsResponse({}));
    }
    /**
     * Sends a card message.
     *
     * @remarks
     *   Make sure that the message template that you want to use has been approved. If the mobile phone number of a recipient does not support card messages, the SendCardSms operation allows the rollback feature to ensure successful delivery.
     * *   When you call the SendCardSms operation to send card messages, the operation checks whether the mobile phone numbers of the recipients support card messages. If the mobile phone numbers do not support card messages, you can specify whether to enable rollback. Otherwise, the card message cannot be delivered.
     * ### QPS limit
     * You can call this operation up to 1,000 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - SendCardSmsRequest
     * @returns SendCardSmsResponse
     */
    async sendCardSms(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.sendCardSmsWithOptions(request, runtime);
    }
    /**
     * Sends a message. Before you call this operation, submit a message signature and message template, and make sure that the signature and template are approved.
     *
     * @remarks
     *   This operation is mainly used to send a single message. In special scenarios, you can send multiple messages with the same content to a maximum of 1,000 mobile numbers. Note that group sending may be delayed.
     * *   To send messages with different signatures and template content to multiple mobile numbers in a single request, call the [SendBatchSms](https://help.aliyun.com/document_detail/102364.html) operation.
     * *   You are charged for using Alibaba Cloud Short Message Service (SMS) based on the amount of messages sent. For more information, see [Pricing](https://www.aliyun.com/price/product#/sms/detail).
     * *   If your verification code signature and general-purpose signature have the same name, the system uses the general-purpose signature to send messages by default.
     *
     * @param request - SendSmsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendSmsResponse
     */
    async sendSmsWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.outId)) {
            query["OutId"] = request.outId;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.phoneNumbers)) {
            query["PhoneNumbers"] = request.phoneNumbers;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        if (!$dara.isNull(request.smsUpExtendCode)) {
            query["SmsUpExtendCode"] = request.smsUpExtendCode;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        if (!$dara.isNull(request.templateParam)) {
            query["TemplateParam"] = request.templateParam;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "SendSms",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new SendSmsResponse({}));
    }
    /**
     * Sends a message. Before you call this operation, submit a message signature and message template, and make sure that the signature and template are approved.
     *
     * @remarks
     *   This operation is mainly used to send a single message. In special scenarios, you can send multiple messages with the same content to a maximum of 1,000 mobile numbers. Note that group sending may be delayed.
     * *   To send messages with different signatures and template content to multiple mobile numbers in a single request, call the [SendBatchSms](https://help.aliyun.com/document_detail/102364.html) operation.
     * *   You are charged for using Alibaba Cloud Short Message Service (SMS) based on the amount of messages sent. For more information, see [Pricing](https://www.aliyun.com/price/product#/sms/detail).
     * *   If your verification code signature and general-purpose signature have the same name, the system uses the general-purpose signature to send messages by default.
     *
     * @param request - SendSmsRequest
     * @returns SendSmsResponse
     */
    async sendSms(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.sendSmsWithOptions(request, runtime);
    }
    /**
     * Reports the status of an OTP message to Alibaba Cloud SMS.
     *
     * @remarks
     * Metrics:
     * *   Requested OTP messages
     * *   Verified OTP messages
     * An OTP conversion rate is calculated based on the following formula: OTP conversion rate = Number of verified OTP messages/Number of requested OTP messages.
     * > If you call the SmsConversion operation to query OTP conversion rates, your business may be affected. We recommend that you perform the following operations: 1. Call the SmsConversion operation in an asynchronous manner by configuring queues or events. 2. Manually degrade your services or use a circuit breaker to automatically degrade services.
     *
     * @param request - SmsConversionIntlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SmsConversionIntlResponse
     */
    async smsConversionIntlWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.conversionTime)) {
            query["ConversionTime"] = request.conversionTime;
        }
        if (!$dara.isNull(request.delivered)) {
            query["Delivered"] = request.delivered;
        }
        if (!$dara.isNull(request.messageId)) {
            query["MessageId"] = request.messageId;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "SmsConversionIntl",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new SmsConversionIntlResponse({}));
    }
    /**
     * Reports the status of an OTP message to Alibaba Cloud SMS.
     *
     * @remarks
     * Metrics:
     * *   Requested OTP messages
     * *   Verified OTP messages
     * An OTP conversion rate is calculated based on the following formula: OTP conversion rate = Number of verified OTP messages/Number of requested OTP messages.
     * > If you call the SmsConversion operation to query OTP conversion rates, your business may be affected. We recommend that you perform the following operations: 1. Call the SmsConversion operation in an asynchronous manner by configuring queues or events. 2. Manually degrade your services or use a circuit breaker to automatically degrade services.
     *
     * @param request - SmsConversionIntlRequest
     * @returns SmsConversionIntlResponse
     */
    async smsConversionIntl(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.smsConversionIntlWithOptions(request, runtime);
    }
    /**
     * openAPI
     *
     * @param tmpReq - SubmitSmsQualificationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SubmitSmsQualificationResponse
     */
    async submitSmsQualificationWithOptions(tmpReq, runtime) {
        tmpReq.validate();
        let request = new SubmitSmsQualificationShrinkRequest({});
        openapi_core_2.OpenApiUtil.convert(tmpReq, request);
        if (!$dara.isNull(tmpReq.businessLicensePics)) {
            request.businessLicensePicsShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.businessLicensePics, "BusinessLicensePics", "json");
        }
        if (!$dara.isNull(tmpReq.otherFiles)) {
            request.otherFilesShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.otherFiles, "OtherFiles", "json");
        }
        let query = {};
        if (!$dara.isNull(request.adminIDCardExpDate)) {
            query["AdminIDCardExpDate"] = request.adminIDCardExpDate;
        }
        if (!$dara.isNull(request.adminIDCardFrontFace)) {
            query["AdminIDCardFrontFace"] = request.adminIDCardFrontFace;
        }
        if (!$dara.isNull(request.adminIDCardNo)) {
            query["AdminIDCardNo"] = request.adminIDCardNo;
        }
        if (!$dara.isNull(request.adminIDCardPic)) {
            query["AdminIDCardPic"] = request.adminIDCardPic;
        }
        if (!$dara.isNull(request.adminIDCardType)) {
            query["AdminIDCardType"] = request.adminIDCardType;
        }
        if (!$dara.isNull(request.adminName)) {
            query["AdminName"] = request.adminName;
        }
        if (!$dara.isNull(request.adminPhoneNo)) {
            query["AdminPhoneNo"] = request.adminPhoneNo;
        }
        if (!$dara.isNull(request.businessLicensePicsShrink)) {
            query["BusinessLicensePics"] = request.businessLicensePicsShrink;
        }
        if (!$dara.isNull(request.bussinessLicenseExpDate)) {
            query["BussinessLicenseExpDate"] = request.bussinessLicenseExpDate;
        }
        if (!$dara.isNull(request.certifyCode)) {
            query["CertifyCode"] = request.certifyCode;
        }
        if (!$dara.isNull(request.companyName)) {
            query["CompanyName"] = request.companyName;
        }
        if (!$dara.isNull(request.companyType)) {
            query["CompanyType"] = request.companyType;
        }
        if (!$dara.isNull(request.legalPersonIDCardNo)) {
            query["LegalPersonIDCardNo"] = request.legalPersonIDCardNo;
        }
        if (!$dara.isNull(request.legalPersonIDCardType)) {
            query["LegalPersonIDCardType"] = request.legalPersonIDCardType;
        }
        if (!$dara.isNull(request.legalPersonIdCardBackSide)) {
            query["LegalPersonIdCardBackSide"] = request.legalPersonIdCardBackSide;
        }
        if (!$dara.isNull(request.legalPersonIdCardEffTime)) {
            query["LegalPersonIdCardEffTime"] = request.legalPersonIdCardEffTime;
        }
        if (!$dara.isNull(request.legalPersonIdCardFrontSide)) {
            query["LegalPersonIdCardFrontSide"] = request.legalPersonIdCardFrontSide;
        }
        if (!$dara.isNull(request.legalPersonName)) {
            query["LegalPersonName"] = request.legalPersonName;
        }
        if (!$dara.isNull(request.organizationCode)) {
            query["OrganizationCode"] = request.organizationCode;
        }
        if (!$dara.isNull(request.otherFilesShrink)) {
            query["OtherFiles"] = request.otherFilesShrink;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.qualificationName)) {
            query["QualificationName"] = request.qualificationName;
        }
        if (!$dara.isNull(request.remark)) {
            query["Remark"] = request.remark;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.useBySelf)) {
            query["UseBySelf"] = request.useBySelf;
        }
        if (!$dara.isNull(request.whetherShare)) {
            query["WhetherShare"] = request.whetherShare;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "SubmitSmsQualification",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new SubmitSmsQualificationResponse({}));
    }
    /**
     * openAPI
     *
     * @param request - SubmitSmsQualificationRequest
     * @returns SubmitSmsQualificationResponse
     */
    async submitSmsQualification(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.submitSmsQualificationWithOptions(request, runtime);
    }
    /**
     * Attaches tags to a message template.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - TagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns TagResourcesResponse
     */
    async tagResourcesWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.prodCode)) {
            query["ProdCode"] = request.prodCode;
        }
        if (!$dara.isNull(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!$dara.isNull(request.resourceId)) {
            query["ResourceId"] = request.resourceId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!$dara.isNull(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "TagResources",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
    }
    /**
     * Attaches tags to a message template.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - TagResourcesRequest
     * @returns TagResourcesResponse
     */
    async tagResources(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.tagResourcesWithOptions(request, runtime);
    }
    /**
     * Deletes tags from a message template.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - UntagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UntagResourcesResponse
     */
    async untagResourcesWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.all)) {
            query["All"] = request.all;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.prodCode)) {
            query["ProdCode"] = request.prodCode;
        }
        if (!$dara.isNull(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!$dara.isNull(request.resourceId)) {
            query["ResourceId"] = request.resourceId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!$dara.isNull(request.tagKey)) {
            query["TagKey"] = request.tagKey;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "UntagResources",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
    }
    /**
     * Deletes tags from a message template.
     *
     * @remarks
     * ### QPS limit
     * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - UntagResourcesRequest
     * @returns UntagResourcesResponse
     */
    async untagResources(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.untagResourcesWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateExtCodeSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateExtCodeSignResponse
     */
    async updateExtCodeSignWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.existExtCode)) {
            query["ExistExtCode"] = request.existExtCode;
        }
        if (!$dara.isNull(request.newExtCode)) {
            query["NewExtCode"] = request.newExtCode;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "UpdateExtCodeSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new UpdateExtCodeSignResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateExtCodeSignRequest
     * @returns UpdateExtCodeSignResponse
     */
    async updateExtCodeSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.updateExtCodeSignWithOptions(request, runtime);
    }
    /**
     * openAPI
     *
     * @param tmpReq - UpdateSmsQualificationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateSmsQualificationResponse
     */
    async updateSmsQualificationWithOptions(tmpReq, runtime) {
        tmpReq.validate();
        let request = new UpdateSmsQualificationShrinkRequest({});
        openapi_core_2.OpenApiUtil.convert(tmpReq, request);
        if (!$dara.isNull(tmpReq.businessLicensePics)) {
            request.businessLicensePicsShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.businessLicensePics, "BusinessLicensePics", "json");
        }
        if (!$dara.isNull(tmpReq.otherFiles)) {
            request.otherFilesShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.otherFiles, "OtherFiles", "json");
        }
        let query = {};
        if (!$dara.isNull(request.adminIDCardExpDate)) {
            query["AdminIDCardExpDate"] = request.adminIDCardExpDate;
        }
        if (!$dara.isNull(request.adminIDCardFrontFace)) {
            query["AdminIDCardFrontFace"] = request.adminIDCardFrontFace;
        }
        if (!$dara.isNull(request.adminIDCardNo)) {
            query["AdminIDCardNo"] = request.adminIDCardNo;
        }
        if (!$dara.isNull(request.adminIDCardPic)) {
            query["AdminIDCardPic"] = request.adminIDCardPic;
        }
        if (!$dara.isNull(request.adminIDCardType)) {
            query["AdminIDCardType"] = request.adminIDCardType;
        }
        if (!$dara.isNull(request.adminName)) {
            query["AdminName"] = request.adminName;
        }
        if (!$dara.isNull(request.adminPhoneNo)) {
            query["AdminPhoneNo"] = request.adminPhoneNo;
        }
        if (!$dara.isNull(request.businessLicensePicsShrink)) {
            query["BusinessLicensePics"] = request.businessLicensePicsShrink;
        }
        if (!$dara.isNull(request.bussinessLicenseExpDate)) {
            query["BussinessLicenseExpDate"] = request.bussinessLicenseExpDate;
        }
        if (!$dara.isNull(request.certifyCode)) {
            query["CertifyCode"] = request.certifyCode;
        }
        if (!$dara.isNull(request.companyName)) {
            query["CompanyName"] = request.companyName;
        }
        if (!$dara.isNull(request.legalPersonIDCardNo)) {
            query["LegalPersonIDCardNo"] = request.legalPersonIDCardNo;
        }
        if (!$dara.isNull(request.legalPersonIDCardType)) {
            query["LegalPersonIDCardType"] = request.legalPersonIDCardType;
        }
        if (!$dara.isNull(request.legalPersonIdCardBackSide)) {
            query["LegalPersonIdCardBackSide"] = request.legalPersonIdCardBackSide;
        }
        if (!$dara.isNull(request.legalPersonIdCardEffTime)) {
            query["LegalPersonIdCardEffTime"] = request.legalPersonIdCardEffTime;
        }
        if (!$dara.isNull(request.legalPersonIdCardFrontSide)) {
            query["LegalPersonIdCardFrontSide"] = request.legalPersonIdCardFrontSide;
        }
        if (!$dara.isNull(request.legalPersonName)) {
            query["LegalPersonName"] = request.legalPersonName;
        }
        if (!$dara.isNull(request.orderId)) {
            query["OrderId"] = request.orderId;
        }
        if (!$dara.isNull(request.otherFilesShrink)) {
            query["OtherFiles"] = request.otherFilesShrink;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.qualificationGroupId)) {
            query["QualificationGroupId"] = request.qualificationGroupId;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "UpdateSmsQualification",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new UpdateSmsQualificationResponse({}));
    }
    /**
     * openAPI
     *
     * @param request - UpdateSmsQualificationRequest
     * @returns UpdateSmsQualificationResponse
     */
    async updateSmsQualification(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.updateSmsQualificationWithOptions(request, runtime);
    }
    /**
     * Update Text SMS Signature
     *
     * @remarks
     * - For details about the changes of this new interface and the original one, please refer to [Announcement on the Update of SMS Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - Only signatures that have not passed the review can be modified. Please refer to [Handling Suggestions for Failed SMS Reviews](https://help.aliyun.com/zh/sms/user-guide/causes-of-application-failures-and-suggestions?spm) and call this interface to modify and resubmit for review after modification.
     * - Signature information applied through the interface will be synchronized in the SMS service console. For operations related to signatures in the console, please see [SMS Signatures](https://help.aliyun.com/zh/sms/user-guide/create-signatures?spm).
     *
     * @param tmpReq - UpdateSmsSignRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateSmsSignResponse
     */
    async updateSmsSignWithOptions(tmpReq, runtime) {
        tmpReq.validate();
        let request = new UpdateSmsSignShrinkRequest({});
        openapi_core_2.OpenApiUtil.convert(tmpReq, request);
        if (!$dara.isNull(tmpReq.moreData)) {
            request.moreDataShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.moreData, "MoreData", "json");
        }
        let query = {};
        if (!$dara.isNull(request.applySceneContent)) {
            query["ApplySceneContent"] = request.applySceneContent;
        }
        if (!$dara.isNull(request.authorizationLetterId)) {
            query["AuthorizationLetterId"] = request.authorizationLetterId;
        }
        if (!$dara.isNull(request.moreDataShrink)) {
            query["MoreData"] = request.moreDataShrink;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.qualificationId)) {
            query["QualificationId"] = request.qualificationId;
        }
        if (!$dara.isNull(request.remark)) {
            query["Remark"] = request.remark;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.signName)) {
            query["SignName"] = request.signName;
        }
        if (!$dara.isNull(request.signSource)) {
            query["SignSource"] = request.signSource;
        }
        if (!$dara.isNull(request.signType)) {
            query["SignType"] = request.signType;
        }
        if (!$dara.isNull(request.thirdParty)) {
            query["ThirdParty"] = request.thirdParty;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "UpdateSmsSign",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new UpdateSmsSignResponse({}));
    }
    /**
     * Update Text SMS Signature
     *
     * @remarks
     * - For details about the changes of this new interface and the original one, please refer to [Announcement on the Update of SMS Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - Only signatures that have not passed the review can be modified. Please refer to [Handling Suggestions for Failed SMS Reviews](https://help.aliyun.com/zh/sms/user-guide/causes-of-application-failures-and-suggestions?spm) and call this interface to modify and resubmit for review after modification.
     * - Signature information applied through the interface will be synchronized in the SMS service console. For operations related to signatures in the console, please see [SMS Signatures](https://help.aliyun.com/zh/sms/user-guide/create-signatures?spm).
     *
     * @param request - UpdateSmsSignRequest
     * @returns UpdateSmsSignResponse
     */
    async updateSmsSign(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.updateSmsSignWithOptions(request, runtime);
    }
    /**
     * Update Text SMS Template
     *
     * @remarks
     * - For details about the changes of this new interface compared to the original one, please refer to [Announcement on SMS Service Update: Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - Only templates that have not passed the review can be modified. Please refer to [Handling Suggestions for Failed SMS Template Reviews](https://help.aliyun.com/zh/sms/user-guide/causes-of-application-failures-and-suggestions?spm=a2c4g.11186623.0.0.4bf5561ajcFtMQ) and call this interface to modify and resubmit for review.
     * - Modifications made through the interface will be synchronized in the SMS service console. For related operations on templates in the console, see [SMS Templates](https://help.aliyun.com/zh/sms/user-guide/message-templates/?spm=a2c4g.11186623.0.0.35a947464Itaxp).
     * ### QPS Limit
     * The single-user QPS limit for this interface is 1000 times/second. Exceeding this limit will result in API throttling, which may impact your business. Please make calls reasonably.
     *
     * @param tmpReq - UpdateSmsTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateSmsTemplateResponse
     */
    async updateSmsTemplateWithOptions(tmpReq, runtime) {
        tmpReq.validate();
        let request = new UpdateSmsTemplateShrinkRequest({});
        openapi_core_2.OpenApiUtil.convert(tmpReq, request);
        if (!$dara.isNull(tmpReq.moreData)) {
            request.moreDataShrink = openapi_core_2.OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.moreData, "MoreData", "json");
        }
        let query = {};
        if (!$dara.isNull(request.applySceneContent)) {
            query["ApplySceneContent"] = request.applySceneContent;
        }
        if (!$dara.isNull(request.intlType)) {
            query["IntlType"] = request.intlType;
        }
        if (!$dara.isNull(request.moreDataShrink)) {
            query["MoreData"] = request.moreDataShrink;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.relatedSignName)) {
            query["RelatedSignName"] = request.relatedSignName;
        }
        if (!$dara.isNull(request.remark)) {
            query["Remark"] = request.remark;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!$dara.isNull(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        if (!$dara.isNull(request.templateContent)) {
            query["TemplateContent"] = request.templateContent;
        }
        if (!$dara.isNull(request.templateName)) {
            query["TemplateName"] = request.templateName;
        }
        if (!$dara.isNull(request.templateRule)) {
            query["TemplateRule"] = request.templateRule;
        }
        if (!$dara.isNull(request.templateType)) {
            query["TemplateType"] = request.templateType;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "UpdateSmsTemplate",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new UpdateSmsTemplateResponse({}));
    }
    /**
     * Update Text SMS Template
     *
     * @remarks
     * - For details about the changes of this new interface compared to the original one, please refer to [Announcement on SMS Service Update: Signature & Template Interfaces](https://help.aliyun.com/zh/sms/product-overview/announcement-on-sms-service-update-signature-template-interface).
     * - Only templates that have not passed the review can be modified. Please refer to [Handling Suggestions for Failed SMS Template Reviews](https://help.aliyun.com/zh/sms/user-guide/causes-of-application-failures-and-suggestions?spm=a2c4g.11186623.0.0.4bf5561ajcFtMQ) and call this interface to modify and resubmit for review.
     * - Modifications made through the interface will be synchronized in the SMS service console. For related operations on templates in the console, see [SMS Templates](https://help.aliyun.com/zh/sms/user-guide/message-templates/?spm=a2c4g.11186623.0.0.35a947464Itaxp).
     * ### QPS Limit
     * The single-user QPS limit for this interface is 1000 times/second. Exceeding this limit will result in API throttling, which may impact your business. Please make calls reasonably.
     *
     * @param request - UpdateSmsTemplateRequest
     * @returns UpdateSmsTemplateResponse
     */
    async updateSmsTemplate(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.updateSmsTemplateWithOptions(request, runtime);
    }
    /**
     * 
     *
     * @param request - ValidPhoneCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ValidPhoneCodeResponse
     */
    async validPhoneCodeWithOptions(request, runtime) {
        request.validate();
        let query = {};
        if (!$dara.isNull(request.certifyCode)) {
            query["CertifyCode"] = request.certifyCode;
        }
        if (!$dara.isNull(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!$dara.isNull(request.phoneNo)) {
            query["PhoneNo"] = request.phoneNo;
        }
        if (!$dara.isNull(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!$dara.isNull(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new openapi_core_2.$OpenApiUtil.OpenApiRequest({
            query: openapi_core_2.OpenApiUtil.query(query),
        });
        let params = new openapi_core_2.$OpenApiUtil.Params({
            action: "ValidPhoneCode",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $dara.cast(await this.callApi(params, req, runtime), new ValidPhoneCodeResponse({}));
    }
    /**
     * 
     *
     * @param request - ValidPhoneCodeRequest
     * @returns ValidPhoneCodeResponse
     */
    async validPhoneCode(request) {
        let runtime = new $dara.RuntimeOptions({});
        return await this.validPhoneCodeWithOptions(request, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map